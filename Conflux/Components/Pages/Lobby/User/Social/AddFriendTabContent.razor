@using Conflux.Components.Shared
@using Conflux.Components.Shared.Icons
@using Conflux.Database
@using Conflux.Database.Entities
@using Conflux.Helpers
@using Conflux.Services.Abstracts
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore
@using System.Collections.Concurrent
@using System.Diagnostics
@using System.Security.Claims

@implements IDisposable

@inject ILogger<AddFriendTabContent> Logger
@inject UserManager<ApplicationUser> UserManager

@* TODO: Change to use IDbContextFactory instead? *@
@inject ApplicationDbContext ApplicationDatabase
@inject IFriendshipService FriendshipService
@inject IWebHostEnvironment Environment
@inject INotificationService NotificationService

<div class="flex-none px-3 outline-none border rounded-lg bg-gray-700/60 border-gray-600 focus-within:ring-2 focus-within:ring-indigo-600 transition duration-300 flex flex-row items-center">
    <Search class="size-4 fill-white flex-none mr-2"/>

    <input type="text" class="flex-1 outline-none border-none w-full h-11 focus:outline-none" @bind="_nameSearch" @bind:after="HandleSearchDebouncing" maxlength="32">
</div>

<div class="flex-1 overflow-auto mt-2 border border-gray-600 rounded-lg">
    <Virtualize @ref="_virtualizeContainer" ItemsProvider="LoadProvider" OverscanCount="3">
        <ChildContent Context="item">
            @* <UserSearchResultElement Item="item" UserId="@_userId"/> *@
            
            <div class="h-16 px-4 py-1 border-b border-b-gray-600 flex flex-row items-center hover:bg-gray-600/40 group">
                <Avatar ImageSrc="@item.AvatarImagePath" ImageAlt="@(item.AvatarImagePath != null ? "Avatar" : string.Empty)" ScaleX="item.AvatarScaleX" ScaleY="item.AvatarScaleY" class="flex-none h-12 mr-2"/>
            
                <div class="flex-1 flex flex-col">
                    <p class="font-semibold">@item.DisplayName</p>
                    <p class="text-sm">@item.UserName</p>
                </div>
            
                <div class="flex-none flex-row gap-1 hidden group-hover:flex">
                    @{
                        FriendRequestProcessingAction action;
                    }
                    
                    @switch (item.FriendStatus) {
                        case FriendStatus.Friend:
                            <div class="p-2 rounded-full">
                                <Person Addition="PersonAddition.Check" class="size-6 fill-red-400"/>
                            </div>
                            break;

                        case FriendStatus.Stranger:
                            <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(item.Id, out action) && action == FriendRequestProcessingAction.Sending)" class="p-2 rounded-full" NormalCssClass="hover:bg-gray-400/50 cursor-pointer" @onclick="@(() => HandleFriendRequest(item))">
                                <ChildContent>
                                    <Person Addition="PersonAddition.Add" class="size-6 fill-white"/>
                                </ChildContent>

                                <ProcessingContent>
                                    <Spinner class="size-6 fill-white"/>
                                </ProcessingContent>
                            </ProcessingStateButton>
                            break;

                        case FriendStatus.Pending:
                            <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(item.Id, out action) && action == FriendRequestProcessingAction.Cancelling)" class="p-2 rounded-full" NormalCssClass="hover:bg-gray-400/50 cursor-pointer" @onclick="@(() => HandleCancelFriendRequest(item))">
                                <ChildContent>
                                    <Person Addition="PersonAddition.Dash" class="size-6 fill-red-400"/>
                                </ChildContent>

                                <ProcessingContent>
                                    <Spinner class="size-6 fill-white"/>
                                </ProcessingContent>
                            </ProcessingStateButton>
                            break;
                    }

                    <button class="p-2 rounded-full hover:bg-gray-400/50 cursor-pointer">
                        <ThreeDots class="size-6 fill-white"/>
                    </button>
                </div>
            </div>
        </ChildContent>
        
        <EmptyContent>
            <div class="flex flex-row justify-center items-center h-full">
                <p class="text-gray-400">Empty...</p>
            </div>
        </EmptyContent>
    </Virtualize>
</div>

@code {
    private string _nameSearch = string.Empty;
    private string _normalizedNameSearch = string.Empty;

    // TODO: First search always have to wait before result display, can we skip that and only wait on
    // later searches?
    private Debouncer _searchDebouncer = null!;

    private Virtualize<UserSearchResult> _virtualizeContainer = null!;

    [CascadingParameter] private Task<AuthenticationState> AuthenticationState { get; set; } = null!;
    private string _userId = null!;

    private ConcurrentDictionary<string, FriendRequestProcessingAction> _processingFriendRequests = [];

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            _searchDebouncer = new(Logger, OnDebounceEnd, TimeSpan.FromMilliseconds(250));

            var authState = await AuthenticationState;
            _userId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier)!;
            
            Debug.Assert(_userId != null);

            NotificationService.OnFriendRequestCanceled += OnFriendRequestCanceledNotification;
            NotificationService.OnFriendRequestRejected += OnFriendRequestRejectedNotification;
        }
    }

    private async Task HandleSearchDebouncing() {
        await _searchDebouncer.Start();
    }

    private async Task OnDebounceEnd(CancellationToken token) {
        _normalizedNameSearch = UserManager.NormalizeName(_nameSearch);

        await _virtualizeContainer.RefreshDataAsync();
        StateHasChanged();
    }

    private async ValueTask<ItemsProviderResult<UserSearchResult>> LoadProvider(ItemsProviderRequest request) {
        if (string.IsNullOrEmpty(_normalizedNameSearch)) {
            return new([], 0);
        }
        
        // Double roundtrip to the database, but it gets the job done.
        
        // TODO: Filter user blocking.
        var query = ApplicationDatabase.Users
            .Where(u => u.IsProfileSetup && u.EmailConfirmed && u.Id != _userId && (u.NormalizedUserName!.Contains(_normalizedNameSearch) || EF.Functions.ILike(u.DisplayName, $"%{_normalizedNameSearch}%")))
            .OrderBy(u => u.CreatedAt);
        
        int totalCount = await query.CountAsync();

        if (totalCount == 0) {
            return new([], 0);
        }
        
        List<UserSearchResult> results = await query
            .Skip(request.StartIndex)
            .Take(request.Count)
            .Select(user => new UserSearchResult {
                Id = user.Id,
                AvatarImagePath = user.ProfilePicturePath,
                UserName = user.UserName!,
                DisplayName = user.DisplayName,
                AvatarScaleX = user.ProfilePictureScaleX,
                AvatarScaleY = user.ProfilePictureScaleY,
                FriendStatus = ApplicationDatabase.FriendRequests
                    .Where(fr => fr.SenderId == _userId && fr.ReceiverId == user.Id)
                    .Select(fr => fr.Status == FriendRequestStatus.Accepted ? FriendStatus.Friend : fr.Status == FriendRequestStatus.Pending ? FriendStatus.Pending : FriendStatus.Stranger)
                    .FirstOrDefault(),
            })
            .ToListAsync();

        return new(results, totalCount);
    }
    
    private async Task HandleFriendRequest(UserSearchResult item) {
        if (_processingFriendRequests.TryAdd(item.Id, FriendRequestProcessingAction.Sending)) {
            try {
                string receiverId = item.Id;

                if (Environment.IsDevelopment()) {
                    await Task.Delay(1000);
                }

                if (await FriendshipService.SendFriendRequest(_userId, receiverId)) {
                    item.FriendStatus = FriendStatus.Pending;
                } else {
                    Logger.LogWarning("Failed to send friend request from user {f} to {r}.", _userId, receiverId);
                }
            } finally {
                _processingFriendRequests.TryRemove(item.Id, out _);

                if (_processingFriendRequests.IsEmpty) {
                    StateHasChanged();
                }
            }
        }
    }

    private async Task HandleCancelFriendRequest(UserSearchResult item) {
        if (_processingFriendRequests.TryAdd(item.Id, FriendRequestProcessingAction.Cancelling)) {
            try {
                string receiverId = item.Id;

                if (Environment.IsDevelopment()) {
                    await Task.Delay(1000);
                }

                if (await FriendshipService.CancelFriendRequest(_userId, receiverId)) {
                    item.FriendStatus = FriendStatus.Stranger;
                } else {
                    Logger.LogWarning("Failed to cancel friend request from user {f} to {r}.", _userId, receiverId);
                }
            } finally {
                _processingFriendRequests.TryRemove(item.Id, out _);

                if (_processingFriendRequests.IsEmpty) {
                    StateHasChanged();
                }
            }
        }
    }
    
    private void OnFriendRequestRejectedNotification(FriendRequestRejectedNotification notification) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }

    private void OnFriendRequestCanceledNotification(FriendRequestCanceledNotification notification) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }

    public void Dispose() {
        _searchDebouncer.Dispose();
        
        NotificationService.OnFriendRequestCanceled -= OnFriendRequestCanceledNotification;
        NotificationService.OnFriendRequestRejected -= OnFriendRequestRejectedNotification;
    }

    private enum FriendRequestProcessingAction {
        Sending,
        Cancelling,
    }
}