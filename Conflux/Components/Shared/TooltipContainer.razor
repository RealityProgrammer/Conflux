@using System.Globalization

@implements IAsyncDisposable

@inject IJSRuntime JavascriptRuntime
@inject ILogger<TooltipContainer> Logger

@* Have to anchor the slot like a loser *@
<div @ref="_target" class="inline-block">
    @Target
</div>

@if (ShowTooltip) {
    <div class="absolute inset-0 pointer-events-none" tabindex="-1">
        <div class="absolute top-0 left-0 @_class" @attributes="AdditionalAttributes" @ref="_tooltip" hidden>
            @Tooltip

            <div class="absolute size-2 rotate-45 @ArrowCssClass" @ref="_arrow"></div>
        </div>
    </div>
}

@code {
    private IJSObjectReference? _module;
    private DotNetObjectReference<TooltipContainer>? _objectReference;
    
    [Parameter, EditorRequired] public required RenderFragment Target { get; set; }
    [Parameter, EditorRequired] public required RenderFragment Tooltip { get; set; }
    
    [Parameter] public bool ShowTooltip { get; set; }
    [Parameter] public EventCallback<bool> ShowTooltipChanged { get; set; }
    
    [Parameter] public string? ArrowCssClass { get; set; }
    [Parameter] public string TooltipPlacement { get; set; } = "bottom";
    [Parameter] public int TooltipOffset { get; set; }

    [Parameter] public bool CloseWhenClickOutside { get; set; }
    
    [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    private string? _class;

    private ElementReference _target, _tooltip, _arrow;

    private int _tooltipId;

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            _module = await JavascriptRuntime.InvokeAsync<IJSObjectReference>("import", "./js/Components/Tooltip.js");
            _objectReference = DotNetObjectReference.Create(this);
        }

        if (ShowTooltip) {
            if (_tooltipId == 0) {
                _tooltipId = await _module!.InvokeAsync<int>("registerTooltip", _target, _tooltip, _arrow, TooltipPlacement, TooltipOffset, _objectReference, CloseWhenClickOutside);
            }
        } else if (_tooltipId != 0) {
            await _module!.InvokeVoidAsync("unregisterTooltip", _tooltipId);
            _tooltipId = 0;
        }
    }

    protected override void OnParametersSet() {
        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("class", out object? obj)) {
            _class = Convert.ToString(obj, CultureInfo.InvariantCulture);
        }

        AdditionalAttributes = AdditionalAttributes?.Where(x => x.Key != "class").ToDictionary();
    }

    [JSInvokable]
    public async Task HandleOutsideClick() {
        if (!CloseWhenClickOutside) return;
        
        Logger.LogInformation("Close Outside.");

        if (ShowTooltipChanged.HasDelegate) {
            await ShowTooltipChanged.InvokeAsync(false);
        }
    }

    public async ValueTask DisposeAsync() {
        _objectReference?.Dispose();
        
        if (_module != null) {
            try {
                await _module.InvokeVoidAsync("unregisterTooltip", _tooltipId);
                await _module.DisposeAsync();

                _tooltipId = 0;
            } catch (JSDisconnectedException) {
            }
        }
    }
}