@using Conflux.Components.Shared.Icons
@using Conflux.Database
@using Conflux.Database.Entities
@using Conflux.Services.Abstracts
@using Microsoft.EntityFrameworkCore
@using System.Security.Claims

@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IJSRuntime JavascriptRuntime
@inject IConversationService ConversationService

<section class="flex flex-col @_cssClass">
    <div class="overflow-y-auto flex-1" @ref="_scrollContainer">
        @switch (_initStatus) {
            case InitializationStatus.Loading:
                <div class="size-full flex flex-row justify-center items-center">
                    <Spinner class="size-16 fill-white"/>
                </div>
                break;
            
            case InitializationStatus.Success:
                <div class="flex flex-row items-center justify-center @(_loadingTop ? "block" : "hidden")">
                    <Spinner class="size-6 fill-white"/>
                </div>

                for (int i = 0, c = _visibleMessages.Count; i < c;) {
                    ChatMessage message = _visibleMessages[i];
                    
                    <div class="px-2 py-0.5 flex flex-row">
                        <Avatar ImageSrc="@message.Sender.AvatarProfilePath"
                                ImageAlt="@(string.IsNullOrEmpty(message.Sender.AvatarProfilePath) ? string.Empty : "Sender Avatar")"
                                ScaleX="message.Sender.AvatarScaleX"
                                ScaleY="message.Sender.AvatarScaleY"
                                class="flex-none size-10 mr-2 mt-1"/>
                    
                        <div class="flex-1 flex flex-col">
                            <p>@message.Sender.DisplayName</p>
                            <p class="relative bg-transparent hover:bg-white/10">
                                @message.Body
                            </p>
                            
                            @{ int j = i + 1; }
                            
                            @for (; j < c; j++) {
                                ChatMessage message2 = _visibleMessages[j];

                                if (message.SenderId == message2.SenderId) {
                                    <p class="relative bg-transparent hover:bg-white/10 group">
                                        @message2.Body

                                        <span class="px-1 py-1 top-0 right-4 -translate-y-1/2 absolute bg-gray-750 rounded-lg hidden group-hover:flex flex-row items-center gap-1">
                                            <p class="text-sm">@message.CreatedAt.ToString("yyyy/MM/dd HH:mm:ss")</p>

                                            <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md">
                                                <Pencil class="size-5 fill-white"></Pencil>
                                            </button>

                                            <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md">
                                                <TurnArrow class="size-5 fill-none stroke-white"/>
                                            </button>

                                            <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md">
                                                <ThreeDots class="size-5 fill-white"></ThreeDots>
                                            </button>
                                        </span>
                                    </p>
                                } else break;
                            }
                            
                            @{
                                i = j;
                            }
                        </div>
                    </div>
                }
                
                <div class="flex flex-row items-center justify-center @(_loadingBottom ? "block" : "hidden")">
                    <Spinner class="size-6 fill-white"/>
                </div>
                break;
        }
    </div>
    
    <MessageInputArea class="flex-none p-2 flex flex-row items-center gap-1"
                      disabled="@(_initStatus != InitializationStatus.Success)"
                      OnSubmit="HandleMessageSend"/>
</section>

@code {
    [Parameter, EditorRequired] public required Guid ConversationId { get; set; }
    [Parameter, EditorRequired] public required int OverloadCount { get; set; }

    [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    private string? _cssClass;

    private InitializationStatus _initStatus = InitializationStatus.Loading;
    private bool _loadingTop, _loadingBottom, _endTop, _endBottom;
    private ElementReference _scrollContainer;
    
    // Storing messages in time ascending order.
    private List<ChatMessage> _visibleMessages = [];
    private DateTime _topLoadTimestamp, _bottomLoadTimestamp;
    
    private IJSObjectReference? _module;
    private DotNetObjectReference<MessagingArea>? _objectReference;

    private ScrollInfo? _savedScrollPositionForTop, _savedScrollPositionForBottom;
    private bool _jumpToBottom;
    private Guid? _jumpToMessageId;
    
    [CascadingParameter] private Task<AuthenticationState> AuthenticationState { get; set; } = null!;
    private string _userId = null!;

    protected override async Task OnInitializedAsync() {
        var authState = await AuthenticationState;
        _userId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier)!;

        if (string.IsNullOrEmpty(_userId)) {
            _initStatus = InitializationStatus.NoPermission;
        }
    }
    
    // Called automatically when URL parameter changed.
    protected override void OnParametersSet() {
        if (_initStatus == InitializationStatus.NoPermission) return;
        
        _initStatus = InitializationStatus.Loading;
        
        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("class", out object? obj)) {
            _cssClass = Convert.ToString(obj);
        }

        AdditionalAttributes = AdditionalAttributes?.Where(x => x.Key is not "class").ToDictionary();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            _module = await JavascriptRuntime.InvokeAsync<IJSObjectReference>("import",  "./Components/Shared/MessagingArea.razor.js");
            _objectReference = DotNetObjectReference.Create(this);
            
            await _module!.InvokeVoidAsync("initializeScrollContainer", _scrollContainer, _objectReference);
        }

        if (_initStatus == InitializationStatus.Loading) {
            await LoadInitialMessages();
            _initStatus = InitializationStatus.Success;
            
            StateHasChanged();
        }

        if (!firstRender) {
            if (_jumpToBottom) {
                _jumpToBottom = false;
                
                await _module!.InvokeVoidAsync("scrollToBottom", _scrollContainer);
            }
        
            if (_jumpToMessageId.HasValue) {
                await _module!.InvokeVoidAsync("jumpToMessage", _scrollContainer, _jumpToMessageId.Value);
                _jumpToMessageId = null;
            }
            
            if (_savedScrollPositionForTop != null) {
                await _module!.InvokeVoidAsync("restoreScrollPositionForTop", _scrollContainer, _savedScrollPositionForTop);
                _savedScrollPositionForTop = null;
            }
            
            if (_savedScrollPositionForBottom != null) {
                await _module!.InvokeVoidAsync("restoreScrollPositionForBottom", _scrollContainer, _savedScrollPositionForBottom);
                _savedScrollPositionForBottom = null;
            }
        }
    }
    
    private async Task LoadInitialMessages() {
        _visibleMessages.Clear();
        
        await using (var dbContext = await DbContextFactory.CreateDbContextAsync()) {
            dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
                    
            // if (InitiallyFocusMessageId.HasValue) {
            //     _visibleMessages = await LoadAroundMessages(dbContext, InitiallyFocusMessageId!.Value);
            //     _jumpToMessageId = InitiallyFocusMessageId!.Value;
            //
            //     if (_visibleMessages.Count > 0) {
            //         _topLoadTimestamp = _visibleMessages[0].CreatedAt;
            //         _bottomLoadTimestamp = _visibleMessages[^1].CreatedAt;
            //     }
            // }

            // if (_visibleMessages.Count == 0) {
                // Load past messages.
                _visibleMessages.AddRange(await LoadTopMessages(dbContext));
                _endBottom = _jumpToBottom = true;

                if (_visibleMessages.Count > 0) {
                    _endTop = false;
                    _topLoadTimestamp = _visibleMessages[0].CreatedAt;
                } else {
                    _endTop = true;
                }
            // }
        }
    }

    [JSInvokable]
    public async Task HandleLoadTopMessages() {
        if (_endTop) return;
        if (Interlocked.Exchange(ref _loadingTop, true)) return;
        
        await InvokeAsync(StateHasChanged); // Re-render to display the load spinner.

        try {
            _savedScrollPositionForTop = await _module!.InvokeAsync<ScrollInfo>("saveScrollPosition", _scrollContainer);
        
            await using (var dbContext = await DbContextFactory.CreateDbContextAsync()) {
                var loadResult = await LoadTopMessages(dbContext, _topLoadTimestamp);

                if (loadResult.Count == 0) {
                    _endTop = true;
                } else {
                    _endTop = false;
                    _topLoadTimestamp = loadResult[0].CreatedAt;
                    
                    _visibleMessages.InsertRange(0, loadResult);
                }
            }
        } finally {
            Interlocked.Exchange(ref _loadingTop, false);
            await InvokeAsync(StateHasChanged);
        }
    }
    
    [JSInvokable]
    public async Task HandleLoadBottomMessages() {
        if (_endBottom) return;
        if (Interlocked.Exchange(ref _loadingBottom, true)) return;
        
        await InvokeAsync(StateHasChanged); // Re-render to display the load spinner.
        
        try {
            _savedScrollPositionForBottom = await _module!.InvokeAsync<ScrollInfo>("saveScrollPosition", _scrollContainer);
        
            await using (var dbContext = await DbContextFactory.CreateDbContextAsync()) {
                var loadResult = await LoadBottomMessages(dbContext, _bottomLoadTimestamp);

                if (loadResult.Count == 0) {
                    _endBottom = true;
                } else {
                    _endBottom = false;
                    _bottomLoadTimestamp = loadResult[^1].CreatedAt;
                    
                    _visibleMessages.AddRange(loadResult);
                }
            }
        } finally {
            Interlocked.Exchange(ref _loadingBottom, false);
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task<List<ChatMessage>> LoadTopMessages(ApplicationDbContext dbContext) {
        List<ChatMessage> loadedMessages = await dbContext.ChatMessages
            .Where(msg => msg.ConversationId == ConversationId)
            .OrderByDescending(m => m.CreatedAt)
            .Take(OverloadCount)
            .Include(message => message.Sender)
            .Reverse()
            .ToListAsync();

        return loadedMessages;
    }

    private async Task<List<ChatMessage>> LoadTopMessages(ApplicationDbContext dbContext, DateTime loadTimestamp) {
        List<ChatMessage> loadedMessages = await dbContext.ChatMessages
            .Where(msg => msg.ConversationId == ConversationId)
            .OrderByDescending(m => m.CreatedAt)
            .Where(m => m.CreatedAt < loadTimestamp)
            .Take(OverloadCount)
            .Include(message => message.Sender)
            .Reverse()
            .ToListAsync();

        return loadedMessages;
    }
    
    private async Task<List<ChatMessage>> LoadBottomMessages(ApplicationDbContext dbContext, DateTime loadTimestamp) {
        List<ChatMessage> loadedMessages = await dbContext.ChatMessages
            .Where(msg => msg.ConversationId == ConversationId)
            .OrderBy(m => m.CreatedAt)
            .Where(m => m.CreatedAt > loadTimestamp)
            .Take(OverloadCount)
            .Include(message => message.Sender)
            .ToListAsync();

        return loadedMessages;
    }

    private async Task<List<ChatMessage>> LoadAroundMessages(ApplicationDbContext dbContext, Guid messageId) {
        // Get the create time of the message with the required id.

        DateTime dateTime = await dbContext.ChatMessages
            .Where(m => m.Id == messageId && m.ConversationId == ConversationId)
            .Select(m => m.CreatedAt)
            .FirstOrDefaultAsync();

        if (dateTime == default) return [];

        List<ChatMessage> messages = await dbContext.ChatMessages
            .Where(m => m.ConversationId == ConversationId)
            .OrderByDescending(m => m.CreatedAt)
            .Where(m => m.CreatedAt < dateTime)
            .Take(OverloadCount)
            .Include(m => m.Sender)
            .Concat(dbContext.ChatMessages
                .Where(m => m.ConversationId == ConversationId)
                .OrderBy(m => m.CreatedAt)
                .Where(m => m.CreatedAt >= dateTime)
                .Take(OverloadCount)
                .Include(m => m.Sender)
            )
            .OrderBy(m => m.CreatedAt)
            .ToListAsync();

        return messages;
    }

    private async Task HandleMessageSend(string body) {
        if (_initStatus == InitializationStatus.Success) {
            await ConversationService.SendMessageAsync(ConversationId, _userId, body, null);
        }
    }

    private enum InitializationStatus {
        Loading,
        NoPermission,
        Success,
    }

    private record ScrollInfo(double ScrollTop, double ScrollHeight);
}