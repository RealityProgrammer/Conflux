@using Conflux.Components.Shared.Icons
@using Conflux.Database
@using Conflux.Database.Entities
@using Conflux.Services.Abstracts
@using Microsoft.EntityFrameworkCore
@using System.Security.Claims

@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IJSRuntime JavascriptRuntime
@inject IConversationService ConversationService
@inject ILogger<MessagingArea> Logger
@inject IContentService ContentService

<section class="min-w-0 flex flex-col @_cssClass">
    <MessageTimeline @bind-ConversationId="ConversationId" 
                     OnReplyRequested="HandleReplyRequested"
                     UserId="@_userId"
                     LoadCount="LoadCount"/>

    <MessageInputArea @bind-ReplyMessageId="_replyMessageId"
                      class="flex-none p-2"
                      disabled="false"
                      OnSubmit="HandleMessageSend"/>
</section>

@code {
    [Parameter] public Guid ConversationId { get; set; }
    [Parameter] public EventCallback<Guid> ConversationIdChanged { get; set; }
    
    [Parameter, EditorRequired] public required int LoadCount { get; set; }

    [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    private string? _cssClass;

    private Guid? _replyMessageId;

    [CascadingParameter] private Task<AuthenticationState> AuthenticationState { get; set; } = null!;
    private string _userId = null!;

    protected override async Task OnInitializedAsync() {
        var authState = await AuthenticationState;
        _userId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier)!;
    }

    // Called automatically when URL parameter changed.
    protected override void OnParametersSet() {
        _replyMessageId = null;
        
        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("class", out object? obj)) {
            _cssClass = Convert.ToString(obj);
        }

        AdditionalAttributes = AdditionalAttributes?.Where(x => x.Key is not "class").ToDictionary();
    }
    
    private async Task HandleMessageSend(MessageInputArea.MessageData data) {
        if (data.UploadingFiles.Count == 0) {
            // No attachment file, plain and simple.
            await ConversationService.SendMessageAsync(ConversationId, _userId, data.Body, data.ReplyMessageId, []);
        } else {
            // Hell await.

            var browserFileStreams = new List<IConversationService.UploadingAttachment>(data.UploadingFiles.Count);

            try {
                for (int i = 0; i < data.UploadingFiles.Count; i++) {
                    IBrowserFile browserFile = data.UploadingFiles[i].BrowserFile;
                    
                    browserFileStreams.Add(new(browserFile.Name, browserFile.OpenReadStream(ApplicationConstants.MaxAttachmentsSize)));
                }

                var status = await ConversationService.SendMessageAsync(ConversationId, _userId, data.Body, data.ReplyMessageId, browserFileStreams);
                
                GC.KeepAlive(status);
            } finally {
                foreach (var attachment in browserFileStreams) {
                    await attachment.Stream.DisposeAsync();
                }
            }
        }
    }

    private void HandleReplyRequested(Guid messageId) {
        _replyMessageId = messageId;
    }
}