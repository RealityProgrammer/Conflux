@using Conflux.Components.Shared.Icons
@using Conflux.Components.Shared.Modals
@using Conflux.Database
@using Conflux.Database.Entities
@using Conflux.Services
@using Conflux.Services.Abstracts
@using Microsoft.AspNetCore.Components.Rendering
@using Microsoft.EntityFrameworkCore

@inject IJSRuntime JavascriptRuntime
@inject IConversationService ConversationService
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IContentService ContentService
@inject ModalService ModalService
@inject ILogger<MessageTimeline> Logger

@implements IAsyncDisposable

<div class="overflow-y-auto flex-1 @_cssClass" @ref="_scrollContainer" @attributes="AdditionalAttributes">
    @switch (_initStatus) {
        case InitializationStatus.Loading:
            <div class="size-full flex flex-row justify-center items-center">
                <Spinner class="size-16 fill-white"/>
            </div>
            break;
    
        case InitializationStatus.Success:
            <div class="flex flex-row items-center justify-center @(_loadingTop ? "block" : "hidden")">
                <Spinner class="size-6 fill-white"/>
            </div>
    
            for (int i = 0, c = _visibleMessages.Count; i < c;) {
                IConversationService.RenderingMessageDTO message = _visibleMessages[i];
    
                // Render the replying message and avatar of the sender as a start of consecutive message group
    
                if (message.ReplyMessageId.HasValue) {
                    Guid replyMessageId = message.ReplyMessageId.Value;

                    @if (replyMessageId != Guid.Empty && _replyMessages.TryGetValue(replyMessageId, out var replyMessage)) {
                        <p class="mt-2 px-2 py-1 text-sm whitespace-nowrap overflow-hidden text-ellipsis border border-gray-600 mx-2 rounded-lg bg-gray-725 shadow-md">
                            @replyMessage.SenderDisplayName: <br/>"@replyMessage.Body"
                        </p>
                    } else {
                        <p class="mt-2 px-2 py-1 text-sm whitespace-nowrap overflow-hidden text-ellipsis border border-gray-600 mx-2 rounded-lg bg-gray-725 shadow-md">
                            Replied message has been deleted.
                        </p>
                    }
                }
    
                <div class="px-2 py-0.5 flex flex-row">
                    @if (message.ReplyMessageId.HasValue) {
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="1.5" class="size-6 fill-none stroke-white mt-2 ml-2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m16.49 12 3.75 3.75m0 0-3.75 3.75m3.75-3.75H3.74V0" />
                        </svg>
                    }
    
                    <Avatar ImageSrc="@(string.IsNullOrEmpty(message.SenderAvatar) ? null : ContentService.GetAssetPath(message.SenderAvatar))"
                            ImageAlt="Sender's Avatar"
                            class="flex-none size-10 mr-2 mt-1"/>
    
                    <div class="flex-1 flex flex-col">
                        <p>@message.SenderDisplayName</p>
    
                        @{
                            // Render the content of consecutive messages.
                            int endIndex = i + 1;
    
                            if (!message.ReplyMessageId.HasValue) {
                                while (endIndex < c && _visibleMessages[endIndex].SenderId == message.SenderId && !_visibleMessages[endIndex].ReplyMessageId.HasValue) {
                                    endIndex++;
                                }
                            }
    
                            for (int j = i; j < endIndex; j++) {
                                message = _visibleMessages[j];
                                bool isEditing = message.MessageId == _editingMessageId;
    
                                <div class="relative bg-transparent @(isEditing ? string.Empty : "hover:bg-white/5") group">
                                    @if (isEditing) {
                                        <MessageTextArea @ref="_editTextArea"
                                                         @bind-Value="_editMessageBody" 
                                                         class="shrink-0 input-field w-full py-2 overflow-x-hidden overflow-y-auto wrap-break-word break-all resize-none scrollbar-hide shadow-lg max-h-96 my-2"
                                                         OnEnterSubmit="HandleSubmitMessageEdit"
                                                         OnEscape="HandleEscapeRequest"/>
                                    } else {
                                        @if (!string.IsNullOrEmpty(message.Body)) {
                                            <p class="whitespace-pre-wrap wrap-anywhere">
                                                @message.Body
                                                
                                                @if (message.IsEdited) {
                                                    <span class="text-xs text-gray-400"> (edited)</span>
                                                }
                                            </p>
                                        } else {
                                            @if (message.IsEdited) {
                                                <span class="text-xs text-gray-400"> (edited)</span>
                                            }
                                        }

                                        <span class="px-1 py-1 top-0 right-4 -translate-y-1/2 absolute bg-gray-750 rounded-lg hidden group-hover:flex flex-row items-center gap-1">
                                            <p class="text-sm">@message.CreatedAt.ToString("yyyy/MM/dd HH:mm:ss")</p>

                                            @{ Guid actionMessageId = message.MessageId; }

                                            <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md" @onclick="@(() => HandleRequestReply(actionMessageId))">
                                                <TurnArrow class="size-5 fill-none stroke-white"/>
                                            </button>

                                            @if (UserId == message.SenderId) {
                                                <hr class="border-l border-y-transparent border-l-gray-600 h-5"/>

                                                <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md" @onclick="@(() => RequestMessageEdit(actionMessageId))">
                                                    <Pencil class="size-5 fill-white"/>
                                                </button>

                                                <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md" @onclick="@(() => RequestMessageDelete(actionMessageId))">
                                                    <Trashcan class="size-5 fill-red-500"/>
                                                </button>
                                            }

                                            <hr class="border-l border-y-transparent border-l-gray-600 h-5"/>

                                            <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md">
                                                <ThreeDots class="size-5 fill-white"/>
                                            </button>
                                        </span>
                                    }

                                    <div class="min-w-0 p-0.5 flex flex-row flex-wrap gap-1">
                                        @foreach (IConversationService.MessageAttachmentDTO attachment in message.Attachments) {
                                            switch (attachment.Type) {
                                                case MessageAttachmentType.Image:
                                                    <img src="@ContentService.GetAssetPath(attachment.Path)" alt="" class="max-w-3xl max-h-80 h-full rounded-lg aspect-auto">
                                                    break;
                                                        
                                                case MessageAttachmentType.Audio:
                                                    <audio controls class="w-full rounded-lg">
                                                        <source src="@ContentService.GetAssetPath(attachment.Path)">
                                                    </audio>
                                                    break;
                                                        
                                                case MessageAttachmentType.Video:
                                                    <video controls class="max-w-3xl max-h-80 h-full aspect-auto">
                                                        <source src="@ContentService.GetAssetPath(attachment.Path)">
                                                    </video>
                                                    break;
                                                        
                                                default: break;
                                            }
                                        }
                                    </div>
                                </div>
                            }
    
                            i = endIndex;
                        }
                    </div>
                </div>
            }
    
            <div class="flex flex-row items-center justify-center @(_loadingBottom ? "block" : "hidden")">
                <Spinner class="size-6 fill-white"/>
            </div>
            break;
    }
</div>

@code {
    [Parameter, EditorRequired] public required int LoadCount { get; set; }
    [Parameter, EditorRequired] public required string UserId { get; set; }
    
    [Parameter] public Guid ConversationId { get; set; }
    private Guid _previousConversationId;
    
    [Parameter] public EventCallback<Guid> OnReplyRequested { get; set; }
    
    [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    private string? _cssClass;

    // Controls.
    private InitializationStatus _initStatus = InitializationStatus.Loading;
    
    // Elements.
    private ElementReference _scrollContainer;
    
    // Loading tracks.
    private bool _loadingTop, _loadingBottom, _endTop, _endBottom;
    
    // Storing messages in time ascending order.
    private readonly List<IConversationService.RenderingMessageDTO> _visibleMessages = [];
    private readonly Dictionary<Guid, IConversationService.RenderingReplyMessageDTO> _replyMessages = [];
    private SemaphoreSlim? _messageSemaphore;
    
    private DateTime _topLoadTimestamp, _bottomLoadTimestamp;
    
    // Message Delete.
    // private Guid _deletingMessageId;
    
    // Message Edit.
    private Guid _editingMessageId;
    private string? _editMessageBody;
    private MessageTextArea? _editTextArea;
    private bool _focusOnEditTextArea;
    
    // Post re-render controls.
    private bool _jumpToBottom;
    private ScrollInfo? _savedScrollPositionForTop, _savedScrollPositionForBottom;
    
    // JS Module.
    private IJSObjectReference? _module;
    private DotNetObjectReference<MessageTimeline>? _objectReference;

    protected override void OnInitialized() {
        _messageSemaphore ??= new(1, 1);
    }

    protected override void OnParametersSet() {
        if (_previousConversationId != ConversationId) {
            ConversationService.LeaveConversationHubAsync(_previousConversationId);
            _initStatus = InitializationStatus.Loading;
        }

        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("class", out object? obj)) {
            _cssClass = Convert.ToString(obj);
        }

        AdditionalAttributes = AdditionalAttributes?.Where(x => x.Key is not "class").ToDictionary();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            _module = await JavascriptRuntime.InvokeAsync<IJSObjectReference>("import", "./js/Components/MessageTimeline.js");
            _objectReference = DotNetObjectReference.Create(this);

            await _module!.InvokeVoidAsync("initializeScrollContainer", _scrollContainer, _objectReference);
            
            ConversationService.OnMessageReceived += OnMessageReceived;
            ConversationService.OnMessageDeleted += OnMessageDeleted;
            ConversationService.OnMessageEdited += OnMessageEdited;
        } else {
            if (_module != null) {
                if (_jumpToBottom) {
                    _jumpToBottom = false;

                    await _module.InvokeVoidAsync("scrollToBottom", _scrollContainer);
                }

                if (_savedScrollPositionForTop != null) {
                    await _module.InvokeVoidAsync("restoreScrollPositionForTop", _scrollContainer, _savedScrollPositionForTop);
                    _savedScrollPositionForTop = null;
                }

                if (_savedScrollPositionForBottom != null) {
                    await _module.InvokeVoidAsync("restoreScrollPositionForBottom", _scrollContainer, _savedScrollPositionForBottom);
                    _savedScrollPositionForBottom = null;
                }
            }

            if (_focusOnEditTextArea && _editTextArea != null) {
                await _editTextArea.Element!.Value.FocusAsync();
            }

            _focusOnEditTextArea = false;
        }
        
        if (_previousConversationId != ConversationId) {
            await ConversationService.JoinConversationHubAsync(ConversationId);
            
            _previousConversationId = ConversationId;
            
            await LoadInitialMessages();
            _initStatus = InitializationStatus.Success;
            StateHasChanged();
        }
    }
    
    private async Task LoadInitialMessages() {
        await using (var dbContext = await DbContextFactory.CreateDbContextAsync()) {
            dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;

            IConversationService.RenderingMessages messages =
                await ConversationService.LoadMessagesBeforeTimestampAsync(ConversationId, DateTime.MaxValue, LoadCount);

            await _messageSemaphore!.WaitAsync();

            try {
                _visibleMessages.Clear();
                _replyMessages.Clear();

                _visibleMessages.AddRange(messages.VisibleMessages);

                foreach (var replyMessage in messages.RepliedMessages) {
                    _replyMessages.TryAdd(replyMessage.MessageId, replyMessage);
                }

                _endBottom = _jumpToBottom = true;

                if (messages.VisibleMessages.Count > 0) {
                    _endTop = false;
                    _topLoadTimestamp = messages.VisibleMessages[0].CreatedAt;
                } else {
                    _endTop = true;
                }
            } finally {
                _messageSemaphore.Release();
            }
        }
    }

    [JSInvokable]
    public async Task HandleLoadTopMessages() {
        if (_endTop) return;
        if (Interlocked.Exchange(ref _loadingTop, true)) return;

        await InvokeAsync(StateHasChanged); // Re-render to display the load spinner.

        try {
            _savedScrollPositionForTop = await _module!.InvokeAsync<ScrollInfo>("saveScrollPosition", _scrollContainer);

            var messages =
                await ConversationService.LoadMessagesBeforeTimestampAsync(ConversationId, _topLoadTimestamp, LoadCount);

            if (messages.VisibleMessages.Count == 0) {
                _endTop = true;
            } else {
                _endTop = false;
                _topLoadTimestamp = messages.VisibleMessages[0].CreatedAt;

                await _messageSemaphore!.WaitAsync();

                try {
                    _visibleMessages.InsertRange(0, messages.VisibleMessages);

                    foreach (var replyMessage in messages.RepliedMessages) {
                        _replyMessages.TryAdd(replyMessage.MessageId, replyMessage);
                    }
                } finally {
                    _messageSemaphore.Release();
                }
            }
        } finally {
            Interlocked.Exchange(ref _loadingTop, false);
            await InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task HandleLoadBottomMessages() {
        if (_endBottom) return;
        if (Interlocked.Exchange(ref _loadingBottom, true)) return;

        await InvokeAsync(StateHasChanged); // Re-render to display the load spinner.

        try {
            _savedScrollPositionForBottom = await _module!.InvokeAsync<ScrollInfo>("saveScrollPosition", _scrollContainer);

            var messages =
                await ConversationService.LoadMessagesAfterTimestampAsync(ConversationId, _topLoadTimestamp, LoadCount);

            if (messages.VisibleMessages.Count == 0) {
                _endBottom = true;
            } else {
                _endBottom = false;
                _bottomLoadTimestamp = messages.VisibleMessages[^1].CreatedAt;

                await _messageSemaphore!.WaitAsync();

                try {
                    _visibleMessages.AddRange(messages.VisibleMessages);

                    foreach (var replyMessage in messages.RepliedMessages) {
                        _replyMessages.TryAdd(replyMessage.MessageId, replyMessage);
                    }
                } finally {
                    _messageSemaphore.Release();
                }
            }
        } finally {
            Interlocked.Exchange(ref _loadingBottom, false);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleRequestReply(Guid id) {
        await OnReplyRequested.InvokeAsync(id);
    }

    private void RequestMessageEdit(Guid id) {
        _editingMessageId = id;

        foreach (var message in _visibleMessages) {
            if (message.MessageId == id) {
                _editMessageBody = message.Body;
                break;
            }
        }

        _focusOnEditTextArea = true;
    }
    
    private async Task HandleSubmitMessageEdit() {
        _editMessageBody = _editMessageBody?.Trim();

        await ConversationService.EditMessageAsync(_editingMessageId, UserId, _editMessageBody);

        _editingMessageId = Guid.Empty;
        _editMessageBody = string.Empty;
    }

    private void HandleEscapeRequest() {
        _editingMessageId = Guid.Empty;
        _editMessageBody = string.Empty;
    }
    
    private static RenderFragment _deleteConfirmationBody = @<p>Are you sure you want to delete this message?<br/>This action cannot be reverted.</p>;
    
    private void RequestMessageDelete(Guid id) {
        ModalService.Open<DeleteConfirmationModal>(parameters: new Dictionary<string, object> {
            [nameof(DeleteConfirmationModal.Title)] = "Delete Message",
            [nameof(DeleteConfirmationModal.Body)] = _deleteConfirmationBody,
            [nameof(DeleteConfirmationModal.OnConfirmDelete)] = new EventCallback(null, async () => {
                await ConversationService.DeleteMessageAsync(id, UserId);
            }),
        });
    }
    
    private void OnMessageReceived(MessageReceivedEventArgs args) {
        // Only insert if we're at the bottom.
        if (_endBottom && args.ConversationId == ConversationId) {
            InvokeAsync(async () => {
                _jumpToBottom = await _module!.InvokeAsync<bool>("shouldMaintainScrollBottom", _scrollContainer);

                // ChatMessage message = args.Message;

                await using (var dbContext = await DbContextFactory.CreateDbContextAsync()) {
                    var senderData = await dbContext.Users.Where(u => u.Id == args.SenderId).Select(u => new {
                        u.Id,
                        u.DisplayName,
                        u.AvatarProfilePath,
                    }).FirstAsync();

                    IConversationService.RenderingReplyMessageDTO? replyMessage = null;

                    var messageData = await dbContext.ChatMessages
                        .Where(m => m.Id == args.MessageId)
                        .Select(m => new {
                            m.ReplyMessageId,
                            m.Body,
                            m.CreatedAt,
                            Attachments = m.Attachments.Select(a => new IConversationService.MessageAttachmentDTO(a.Name, a.Type, a.PhysicalPath)).ToArray(),
                        })
                        .FirstAsync();

                    if (messageData.ReplyMessageId.HasValue && !_replyMessages.ContainsKey(messageData.ReplyMessageId.Value)) {
                        replyMessage = await dbContext.ChatMessages
                            .Where(m => m.Id == messageData.ReplyMessageId.Value && m.DeletedAt == null)
                            .Include(m => m.Sender)
                            .Select(m => new IConversationService.RenderingReplyMessageDTO(m.Id, m.Sender.DisplayName, m.Body))
                            .FirstOrDefaultAsync();
                    }

                    await _messageSemaphore!.WaitAsync();

                    try {
                        _visibleMessages.Add(new(args.MessageId, senderData.Id, senderData.DisplayName, senderData.AvatarProfilePath, messageData.Body, messageData.CreatedAt, false, messageData.ReplyMessageId, messageData.Attachments));

                        if (replyMessage != null) {
                            _replyMessages.TryAdd(replyMessage.MessageId, replyMessage);
                        }
                    } finally {
                        _messageSemaphore.Release();
                    }

                    StateHasChanged();
                }
            });
        }
    }

    private void OnMessageDeleted(MessageDeletedEventArgs args) {
        if (ConversationId != args.ConversationId) return;

        _messageSemaphore!.Wait();

        try {
            for (int i = 0; i < _visibleMessages.Count; i++) {
                if (_visibleMessages[i].MessageId == args.MessageId) {
                    _visibleMessages.RemoveAt(i);
                    break;
                }
            }

            InvokeAsync(StateHasChanged);
        } finally {
            _messageSemaphore.Release();
        }
    }

    private void OnMessageEdited(MessageEditedEventArgs args) {
        if (ConversationId != args.ConversationId) return;

        _messageSemaphore!.Wait();

        try {
            for (int i = 0; i < _visibleMessages.Count; i++) {
                if (_visibleMessages[i].MessageId == args.MessageId) {
                    _visibleMessages[i] = _visibleMessages[i] with {
                        Body = args.Body,
                        IsEdited = true,
                    };
                    break;
                }
            }

            InvokeAsync(StateHasChanged);
        } finally {
            _messageSemaphore.Release();
        }
    }
    
    public async ValueTask DisposeAsync() {
        ConversationService.OnMessageReceived -= OnMessageReceived;
        ConversationService.OnMessageDeleted -= OnMessageDeleted;
        ConversationService.OnMessageEdited -= OnMessageEdited;

        _messageSemaphore?.Dispose();
        
        await ConversationService.LeaveConversationHubAsync(ConversationId);
    }
    
    private enum InitializationStatus {
        Loading,
        Success,
    }
    
    private record ScrollInfo(double ScrollTop, double ScrollHeight);
}