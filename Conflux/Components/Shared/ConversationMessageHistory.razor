@using Conflux.Components.Shared.Icons
@using Conflux.Database
@using Conflux.Database.Entities
@using Microsoft.EntityFrameworkCore
@using System.Security.Claims

@implements IAsyncDisposable

@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IJSRuntime JavascriptRuntime
@inject ILogger<ConversationMessageHistory> Logger

@switch (_initStatus) {
    case InitializationStatus.Initializing:
        <div class="size-full flex flex-row justify-center items-center">
            <Spinner class="size-16 fill-white"/>
        </div>
        break;
        
    case InitializationStatus.NoPermission:
        <div class="size-full flex flex-row justify-center items-center">
            <p class="text-sm text-gray-400">You have no permission to join this conversation.</p>
        </div>
        break;
        
    case InitializationStatus.Success:
        <div class="overflow-y-auto px-2 @_cssClass" @ref="_scrollContainer">
            @if (_loadingTop) {
                <div class="flex flex-row items-center justify-center">
                    <Spinner class="size-6 fill-white"/>
                </div>
            }
    
            <div class="py-2">
                @for (int i = _visibleMessages.Count - 1; i >= 0; i--) {
                    ChatMessage message = _visibleMessages[i];
                    
                    <div @key="message.Id" class="group flex flex-row mb-2">
                        <Avatar ImageSrc="@message.Sender.AvatarProfilePath" 
                                ImageAlt="@(string.IsNullOrEmpty(message.Sender.AvatarProfilePath) ? string.Empty : "Sender Avatar")" 
                                ScaleX="message.Sender.AvatarScaleX"
                                ScaleY="message.Sender.AvatarScaleY"
                                class="size-10 mr-2"/>
                
                        <div class="flex flex-col">
                            <p>@message.Sender.DisplayName</p>
                            <p>@message.Body</p>
                        </div>
                    </div>
                }
            </div>
    
            @if (_loadingBottom) {
                <div class="flex flex-row items-center justify-center">
                    <Spinner class="size-6 fill-white"/>
                </div>
            }
        </div>
        break;
}

@code {
    [Parameter, EditorRequired] public required Guid ConversationId { get; set; }
    [Parameter] public EventCallback<InitializationStatus> OnInitializeLoaded { get; set; }

    [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    private string? _cssClass;
    
    [CascadingParameter] private Task<AuthenticationState> AuthenticationState { get; set; } = null!;
    private string _userId = null!;

    private InitializationStatus _initStatus = InitializationStatus.Initializing;
    private bool _loadingTop, _loadingBottom, _endTop;
    private ElementReference _scrollContainer;
    private List<ChatMessage> _visibleMessages = [];
    private DateTime _topLoadTimestamp;
    
    private IJSObjectReference? _module;
    private DotNetObjectReference<ConversationMessageHistory>? _objectReference;

    private ScrollInfo? _savedScrollPosition;

    protected override void OnParametersSet() {
        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("class", out object? obj)) {
            _cssClass = Convert.ToString(obj);
        }

        AdditionalAttributes = AdditionalAttributes?.Where(x => x.Key is not "class").ToDictionary();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            _module = await JavascriptRuntime.InvokeAsync<IJSObjectReference>("import",  "./Components/Shared/ConversationMessageHistory.razor.js");
            
            try {
                var authState = await AuthenticationState;
                _userId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier)!;

                if (string.IsNullOrEmpty(_userId)) {
                    _initStatus = InitializationStatus.NoPermission;
                    return;
                }

                var loadResult = await LoadTopMessages(DateTime.MaxValue);

                _endTop = !loadResult.HasMore;
                _topLoadTimestamp = loadResult.NewLoadTimestamp;
                
                _initStatus = InitializationStatus.Success;
                _loadingTop = _loadingBottom = false;
            } finally {
                StateHasChanged();

                if (OnInitializeLoaded.HasDelegate) {
                    await OnInitializeLoaded.InvokeAsync(_initStatus);
                }
            }

            await Task.Yield(); // Might need this, probably...

            _objectReference = DotNetObjectReference.Create(this);

            await _module.InvokeVoidAsync("scrollToBottom", _scrollContainer);
            await _module.InvokeVoidAsync("initializeScrollContainer", _scrollContainer, _objectReference);
        } else {
            if (_savedScrollPosition != null) {
                await _module!.InvokeVoidAsync("restoreScrollPosition", _scrollContainer, _savedScrollPosition);
                _savedScrollPosition = null;
            }
        }
    }

    [JSInvokable]
    public async Task HandleLoadTopMessages() {
        if (_endTop) return;
        if (Interlocked.Exchange(ref _loadingTop, true)) return;
        
        await InvokeAsync(StateHasChanged); // Re-render to display the load spinner.
        
        try {
            _savedScrollPosition = await _module!.InvokeAsync<ScrollInfo>("saveScrollPosition", _scrollContainer);

            var loadResult = await LoadTopMessages(_topLoadTimestamp);

            _endTop = !loadResult.HasMore;
            _topLoadTimestamp = loadResult.NewLoadTimestamp;
        } finally {
            Interlocked.Exchange(ref _loadingTop, false);
            await InvokeAsync(StateHasChanged);
        }
    }
    
    [JSInvokable]
    public async Task HandleLoadBottomMessages() {
        // if (Interlocked.Exchange(ref _loadingBottom, true)) return;
        
        Logger.LogInformation("Load more bottom messages...");

        // Interlocked.Exchange(ref _loadingBottom, false);
    }

    private async Task<MessageLoadResult> LoadTopMessages(DateTime loadTimestamp) {
        MessageLoadResult result = default;
        
        await using (var dbContext = await DbContextFactory.CreateDbContextAsync()) {
            // Hacky way to detect if we ran out of message by loading extra 1 message, if the collection
            // returns the same amount, take only what we need, ignore the extra and note that there are more.
            List<ChatMessage> loadedMessages = await dbContext.ChatMessages
                .Where(msg => msg.ConversationId == ConversationId)
                .OrderByDescending(msg => msg.CreatedAt)
                .Where(m => m.CreatedAt < loadTimestamp)
                .Take(ApplicationConstants.MessageLoadCount + 1)
                .Include(message => message.Sender)
                .ToListAsync();

            result.HasMore = loadedMessages.Count == ApplicationConstants.MessageLoadCount + 1;
            
            for (int i = 0, c = int.Min(ApplicationConstants.MessageLoadCount, loadedMessages.Count); i < c; i++) {
                _visibleMessages.Add(loadedMessages[i]);
            }
                
            result.NewLoadTimestamp = _visibleMessages[^1].CreatedAt;
        }

        return result;
    }
    
    public async ValueTask DisposeAsync() {
        if (_module is not null) {
            try {
                await _module.DisposeAsync();
            } catch (JSDisconnectedException) {
            }
        }
        
        _objectReference?.Dispose();
    }

    public enum InitializationStatus {
        Initializing,
        NoPermission,
        Success,
    }

    public record ScrollInfo(double ScrollTop, double ScrollHeight);

    public record struct MessageLoadResult(bool HasMore, DateTime NewLoadTimestamp);
}