@using Conflux.Domain.Enums
@using Conflux.Web.Core
@using System.Diagnostics
@using System.Security.Claims

@inject IConversationService ConversationService
@inject ILogger<MessagingArea> Logger

<section class="min-w-0 flex flex-col @_cssClass">
    <MessageTimeline ConversationId="ConversationId" 
                     OnReplyRequested="@(DisallowInput ? new EventCallback<Guid>(this, null) : EventCallback.Factory.Create<Guid>(this, HandleReplyRequested))"
                     UserId="@_userId"
                     LoadCount="LoadCount"
                     DisallowReport="DisallowReport"/>

    @if (!DisallowInput) {
        <MessageInputArea @bind-ReplyMessageId="_replyMessageId"
                          class="flex-none p-2"
                          disabled="false"
                          OnSubmit="HandleMessageSend"/>
    }
</section>

@code {
    [Parameter] public Guid ConversationId { get; set; }
    [Parameter] public bool DisallowInput { get; set; }
    [Parameter] public bool DisallowReport { get; set; }
    
    [Parameter, EditorRequired] public required int LoadCount { get; set; }

    [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    private string? _cssClass;

    private Guid? _replyMessageId;

    [CascadingParameter] private Task<AuthenticationState> AuthenticationState { get; set; } = null!;
    private string _userId = null!;

    protected override async Task OnInitializedAsync() {
        var authState = await AuthenticationState;
        _userId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier)!;
    }

    // Called automatically when URL parameter changed.
    protected override void OnParametersSet() {
        _replyMessageId = null;
        
        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("class", out object? obj)) {
            _cssClass = Convert.ToString(obj);
        }

        AdditionalAttributes = AdditionalAttributes?.Where(x => x.Key is not "class").ToDictionary();
    }
    
    private async Task HandleMessageSend(MessageInputArea.MessageData data) {
        if (data.UploadingFiles.Count == 0) {
            // No attachment file, plain and simple.
            await ConversationService.SendMessageAsync(ConversationId, _userId, data.Body, data.ReplyMessageId, []);
        } else {
            // Ensure supported file formats.

            foreach (MessageInputArea.UploadingFile file in data.UploadingFiles) {
                string contentType = file.BrowserFile.ContentType;

                if (contentType.StartsWith("video/") || contentType.StartsWith("audio/") || contentType.StartsWith("image/")) {
                    continue;
                }

                throw new NotImplementedException($"Uploading file with content MIME type '{contentType}' is not implemented.");
            }

            var browserFileStreams = new List<IConversationService.UploadingAttachment>(data.UploadingFiles.Count);

            try {
                foreach (MessageInputArea.UploadingFile file in data.UploadingFiles) {
                    IBrowserFile browserFile = file.BrowserFile;
                    MessageAttachmentType type = browserFile.ContentType switch {
                        _ when browserFile.ContentType.StartsWith("image/") => MessageAttachmentType.Image,
                        _ when browserFile.ContentType.StartsWith("video/") => MessageAttachmentType.Video,
                        _ when browserFile.ContentType.StartsWith("audio/") => MessageAttachmentType.Audio,
                        _ => throw new UnreachableException(),
                    };

                    Stream readStream = new LazyBrowserFileStream(browserFile, ApplicationConstants.MaxSizePerAttachment);
                    
                    browserFileStreams.Add(new(browserFile.Name, type, readStream));
                }

                var status = await ConversationService.SendMessageAsync(ConversationId, _userId, data.Body, data.ReplyMessageId, browserFileStreams);
                
                Logger.LogInformation("Send Message status: {s}", status);
            } finally {
                foreach (var attachment in browserFileStreams) {
                    await attachment.Stream.DisposeAsync();
                }
            }
        }
    }

    private void HandleReplyRequested(Guid messageId) {
        _replyMessageId = messageId;
    }
}