@using Conflux.Application.Dto
@using Conflux.Domain.Enums
@using Conflux.Domain.Events
@using Conflux.Web.Components.Shared.Icons
@using Conflux.Web.Helpers
@using Conflux.Web.Services.Implementations
@using Microsoft.EntityFrameworkCore
@using System.Security.Claims
@using System.Diagnostics

@inject IJSRuntime JavascriptRuntime
@inject IConversationService ConversationService
@inject IConversationEventDispatcher ConversationEventDispatcher
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IContentService ContentService
@inject ModalService ModalService

@implements IAsyncDisposable

<div class="overflow-y-auto flex-1 @_cssClass" @ref="_scrollContainer" @attributes="AdditionalAttributes">
    @switch (_initStatus) {
        case InitializationStatus.Loading:
            <div class="size-full flex flex-row justify-center items-center">
                <Spinner class="size-16 fill-white"/>
            </div>
            break;
    
        case InitializationStatus.Success:
            <div class="flex flex-row items-center justify-center @(_loadingTop ? "block" : "hidden")">
                <Spinner class="size-6 fill-white"/>
            </div>
    
            for (int i = 0, c = _visibleMessages.Count; i < c;) {
                IConversationService.RenderingMessageDTO message = _visibleMessages[i];
    
                // Render the replying message and avatar of the sender as a start of consecutive message group
    
                if (message.ReplyMessageId.HasValue) {
                    Guid replyMessageId = message.ReplyMessageId.Value;

                    @if (replyMessageId != Guid.Empty && _replyMessages.TryGetValue(replyMessageId, out var replyMessage)) {
                        <p class="mt-2 px-2 py-1 text-sm whitespace-nowrap overflow-hidden text-ellipsis border border-gray-600 mx-2 rounded-lg bg-gray-725 shadow-md">
                            @replyMessage.SenderDisplayName: <br/>"@replyMessage.Body"
                        </p>
                    } else {
                        <p class="mt-2 px-2 py-1 text-sm whitespace-nowrap overflow-hidden text-ellipsis border border-gray-600 mx-2 rounded-lg bg-gray-725 shadow-md">
                            Replied message has been deleted.
                        </p>
                    }
                }
    
                <div class="px-2 py-0.5 flex flex-row">
                    @if (message.ReplyMessageId.HasValue) {
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="1.5" class="size-6 fill-none stroke-white mt-2 ml-2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m16.49 12 3.75 3.75m0 0-3.75 3.75m3.75-3.75H3.74V0" />
                        </svg>
                    }
                    
                    @{
                        string senderId = message.SenderId;
                        EventCallback invokesOpenUserModal = EventCallback.Factory.Create(this, EventUtils.AsNonRenderingEventHandler(() => OpenUserProfileModal(senderId)));
                    }
    
                    <Avatar ImageSrc="@(string.IsNullOrEmpty(message.SenderAvatar) ? null : ContentService.GetAssetPath(message.SenderAvatar))"
                            ImageAlt="Sender's Avatar"
                            class="flex-none size-10 mr-2 mt-1 cursor-pointer pointer-events-auto"
                            @onclick="invokesOpenUserModal"/>
    
                    <div class="flex-1 flex flex-col">
                        <div>
                            <p class="select-none hover:underline cursor-pointer inline-block" @onclick="invokesOpenUserModal">@message.SenderDisplayName</p>
                        </div>

                        @{
                            // Render the content of consecutive messages.
                            int endIndex = i + 1;

                            if (!message.ReplyMessageId.HasValue) {
                                while (endIndex < c && _visibleMessages[endIndex].SenderId == message.SenderId && !_visibleMessages[endIndex].ReplyMessageId.HasValue) {
                                    endIndex++;
                                }
                            }

                            for (int j = i; j < endIndex; j++) {
                                message = _visibleMessages[j];
                                bool isEditing = message.MessageId == _editingMessageId;

                                <div class="relative bg-transparent @(isEditing ? string.Empty : "hover:bg-white/5") group">
                                    @if (isEditing) {
                                        <MessageTextArea @ref="_editTextArea"
                                                         @bind-Value="_editMessageBody"
                                                         class="shrink-0 input-field w-full py-2 overflow-x-hidden overflow-y-auto wrap-break-word break-all resize-none scrollbar-hide shadow-lg max-h-96 my-2"
                                                         OnEnterSubmit="HandleSubmitMessageEdit"
                                                         OnEscape="HandleEscapeRequest"
                                                         autofocus/>
                                    } else {
                                        @if (!string.IsNullOrEmpty(message.Body)) {
                                            <p class="whitespace-pre-wrap wrap-anywhere">
                                                @message.Body

                                                @if (message.IsEdited) {
                                                    <span class="text-xs text-gray-400"> (edited)</span>
                                                }
                                            </p>
                                        } else {
                                            @if (message.IsEdited) {
                                                <span class="text-xs text-gray-400"> (edited)</span>
                                            }
                                        }

                                        Guid actionMessageId = message.MessageId;

                                        <span class="px-1 py-1 top-0 right-4 -translate-y-1/2 absolute bg-gray-750 rounded-lg @(_showExtraActionPopover && _extraActionTargetMessage != null && _extraActionTargetMessage.MessageId == actionMessageId ? "flex" : "hidden") group-hover:flex flex-row items-center gap-1">
                                            <p class="text-sm">@message.CreatedAt.ToString("yyyy/MM/dd HH:mm:ss")</p>

                                            @if (OnReplyRequested.HasDelegate) {
                                                <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md" @onclick="@(EventUtils.AsNonRenderingEventHandler(() => HandleMessageReply(actionMessageId)))">
                                                    <TurnArrow class="size-5 fill-none stroke-white"/>
                                                </button>
                                            }

                                            @if (UserId == message.SenderId) {
                                                <hr class="border-l border-y-transparent border-l-gray-600 h-5"/>

                                                <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md" @onclick="@(() => HandleMessageEdit(actionMessageId))">
                                                    <Pencil class="size-5 fill-white"/>
                                                </button>

                                                <button class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md" @onclick="@(() => HandleMessageDelete(actionMessageId))">
                                                    <Trashcan class="size-5 fill-red-500"/>
                                                </button>
                                            }

                                            <hr class="border-l border-y-transparent border-l-gray-600 h-5"/>

                                            @{ var messageCapture = message; }
                                            <button @ref="@(_extraActionPopoverTargets[actionMessageId])" class="p-1 bg-transparent hover:bg-white/15 cursor-pointer rounded-md" @onclick="@(() => HandleShowExtraActionPopover(messageCapture))">
                                                <ThreeDots class="size-5 fill-white"/>
                                            </button>
                                        </span>
                                    }

                                    <div class="min-w-0 p-0.5 flex flex-row flex-wrap gap-1">
                                        @foreach (MessageAttachment attachment in message.Attachments) {
                                            string path = ContentService.GetAssetPath(attachment.PhysicalPath);

                                            switch (attachment.Type) {
                                                case MessageAttachmentType.Image:
                                                    <img src="@path" alt="" class="max-w-3xl max-h-80 h-full rounded-lg aspect-auto">
                                                    break;

                                                case MessageAttachmentType.Audio:
                                                    <audio controls class="w-full rounded-lg">
                                                        <source src="@path">
                                                    </audio>
                                                    break;

                                                case MessageAttachmentType.Video:
                                                    <video controls class="max-w-3xl max-h-80 h-full aspect-auto">
                                                        <source src="@path">
                                                    </video>
                                                    break;
                                            }
                                        }
                                    </div>
                                </div>
                            }

                            i = endIndex;

                        }
                    </div>
                </div>
            }
    
            <div class="flex flex-row items-center justify-center @(_loadingBottom ? "block" : "hidden")">
                <Spinner class="size-6 fill-white"/>
            </div>
            
            <Popover TargetReference="_extraActionTargetElement"
                     @bind-IsShowing:get="_showExtraActionPopover"
                     @bind-IsShowing:set="SetIsShowingExtraActionPopover"
                     ArrowCssClass="bg-gray-750 border-r border-r-gray-600 border-t border-t-gray-600"
                     Placement="left"
                     Offset="8"
                     CloseWhenClickOutside="true"
                     class="w-60 bg-gray-750 text-white flex flex-col gap-1 p-1 rounded-lg shadow-md border border-gray-600">
                @{ Debug.Assert(_extraActionTargetMessage != null); }
                
                @if (OnReplyRequested.HasDelegate) {
                    <button class="p-2! button-nav-menu" @onclick="HandleMessageReplyViaExtra">
                        <TurnArrow class="size-5 fill-none stroke-white"/>

                        <span class="text-sm">Reply Message</span>
                    </button>
                    
                    <hr class="border-t border-t-gray-600 px-2"/>
                }

                @if (_extraActionTargetMessage.SenderId == UserId) {
                    <button class="p-2! button-nav-menu" @onclick="HandleMessageEditViaExtra">
                        <Pencil class="size-5 fill-white"/>
                        
                        <span class="text-sm">Edit Message</span>
                    </button>
                    
                    <button class="p-2! button-nav-menu text-red-500" @onclick="HandleMessageDeleteViaExtra">
                        <Trashcan class="size-5 fill-red-500"/> 
                        
                        <span class="text-sm">Delete Message</span>
                    </button>
                    
                    <hr class="border-t border-t-gray-600 mx-2"/>
                }
                
                <button class="p-2! button-nav-menu" @onclick="HandleCopyMessage">
                    <Copy class="size-5 fill-white"/>
                    
                    <span class="text-sm">Copy Message</span>
                </button>
                
                <button class="p-2! button-nav-menu group" disabled>
                    <Volume Variation="VolumeVariations.Up" class="size-5 fill-white group-disabled:fill-gray-400"/>
                    
                    <span class="text-sm">Speak Message</span>
                </button>
                
                @if (_extraActionTargetMessage!.SenderId != _authUserId && !DisallowReport) {
                    <button class="p-2! button-nav-menu" @onclick="HandleReportMessage">
                        <Flag class="size-5 fill-red-400"/>

                        <span class="text-sm text-red-400">Report Message</span>
                    </button>
                }
            </Popover>
            break;
    }
</div>

@code {
    [Parameter, EditorRequired] public required int LoadCount { get; set; }
    [Parameter, EditorRequired] public required string UserId { get; set; }
    [Parameter] public bool DisallowReport { get; set; }
    
    [Parameter] public Guid ConversationId { get; set; }
    private Guid _previousConversationId;
    
    [Parameter] public EventCallback<Guid> OnReplyRequested { get; set; }
    
    [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    private string? _cssClass;

    [CascadingParameter] private MemberInformationDTO? MemberInformation { get; set; }
    [CascadingParameter] private Task<AuthenticationState> AuthenticationState { get; set; } = null!;

    private string _authUserId = null!;

    // Controls.
    private InitializationStatus _initStatus = InitializationStatus.Loading;
    
    // Elements.
    private ElementReference _scrollContainer;
    
    // Loading tracks.
    private bool _loadingTop, _loadingBottom, _endTop, _endBottom;
    
    // Storing messages in time ascending order.
    private readonly List<IConversationService.RenderingMessageDTO> _visibleMessages = [];
    private readonly Dictionary<Guid, IConversationService.RenderingReplyMessageDTO> _replyMessages = [];
    
    // Extra action
    private readonly Dictionary<Guid, ElementReference> _extraActionPopoverTargets = [];
    private IConversationService.RenderingMessageDTO? _extraActionTargetMessage;
    private ElementReference _extraActionTargetElement;
    private bool _showExtraActionPopover;
    
    private SemaphoreSlim? _messageSemaphore;
    
    private DateTime _topLoadTimestamp, _bottomLoadTimestamp;
    
    // Message Delete.
    // private Guid _deletingMessageId;
    
    // Message Edit.
    private Guid _editingMessageId;
    private string? _editMessageBody;
    private MessageTextArea? _editTextArea;
    private bool _focusOnEditTextArea;
    
    // Post re-render controls.
    private bool _jumpToBottom;
    private ScrollInfo? _savedScrollPositionForTop, _savedScrollPositionForBottom;
    
    // JS Module.
    private IJSObjectReference? _module;
    private DotNetObjectReference<MessageTimeline>? _objectReference;

    protected override void OnInitialized() {
        _messageSemaphore ??= new(1, 1);
    }

    protected override void OnParametersSet() {
        if (_previousConversationId != ConversationId) {
            ConversationEventDispatcher.Disconnect(_previousConversationId);
            _initStatus = InitializationStatus.Loading;

            _extraActionPopoverTargets.Clear();

            _visibleMessages.Clear();
            _replyMessages.Clear();
        }

        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("class", out object? obj)) {
            _cssClass = Convert.ToString(obj);
        }

        AdditionalAttributes = AdditionalAttributes?.Where(x => x.Key is not "class").ToDictionary();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            _module = await JavascriptRuntime.InvokeAsync<IJSObjectReference>("import", "./js/Components/MessageTimeline.js");
            _objectReference = DotNetObjectReference.Create(this);

            await _module!.InvokeVoidAsync("initializeScrollContainer", _scrollContainer, _objectReference);
            
            ConversationEventDispatcher.OnMessageReceived += OnMessageReceived;
            ConversationEventDispatcher.OnMessageDeleted += OnMessageDeleted;
            ConversationEventDispatcher.OnMessageEdited += OnMessageEdited;

            var authState = await AuthenticationState;
            _authUserId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier)!;
        } else {
            if (_module != null) {
                if (_jumpToBottom) {
                    _jumpToBottom = false;

                    await _module.InvokeVoidAsync("scrollToBottom", _scrollContainer);
                }

                if (_savedScrollPositionForTop != null) {
                    await _module.InvokeVoidAsync("restoreScrollPositionForTop", _scrollContainer, _savedScrollPositionForTop);
                    _savedScrollPositionForTop = null;
                }

                if (_savedScrollPositionForBottom != null) {
                    await _module.InvokeVoidAsync("restoreScrollPositionForBottom", _scrollContainer, _savedScrollPositionForBottom);
                    _savedScrollPositionForBottom = null;
                }
            }

            if (_focusOnEditTextArea && _editTextArea != null) {
                await _editTextArea.Element!.Value.FocusAsync();
            }
            
            _focusOnEditTextArea = false;
        }
        
        if (_previousConversationId != ConversationId) {
            await ConversationEventDispatcher.Connect(ConversationId);
            
            _previousConversationId = ConversationId;
            
            await LoadInitialMessages();
            _initStatus = InitializationStatus.Success;
            StateHasChanged();
        }
    }
    
    private async Task LoadInitialMessages() {
        await using (var dbContext = await DbContextFactory.CreateDbContextAsync()) {
            dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;

            IConversationService.RenderingMessages messages =
                await ConversationService.LoadMessagesBeforeTimestampAsync(ConversationId, DateTime.MaxValue, LoadCount);

            await _messageSemaphore!.WaitAsync();

            try {
                _visibleMessages.AddRange(messages.VisibleMessages);

                foreach (var replyMessage in messages.RepliedMessages) {
                    _replyMessages.TryAdd(replyMessage.MessageId, replyMessage);
                }

                _endBottom = _jumpToBottom = true;

                if (messages.VisibleMessages.Count > 0) {
                    _endTop = false;
                    _topLoadTimestamp = messages.VisibleMessages[0].CreatedAt;
                } else {
                    _endTop = true;
                }
            } finally {
                _messageSemaphore.Release();
            }
        }
    }

    [JSInvokable]
    public async Task HandleLoadTopMessages() {
        if (_endTop) return;
        if (Interlocked.Exchange(ref _loadingTop, true)) return;

        await InvokeAsync(StateHasChanged); // Re-render to display the load spinner.

        try {
            _savedScrollPositionForTop = await _module!.InvokeAsync<ScrollInfo>("saveScrollPosition", _scrollContainer);

            var messages =
                await ConversationService.LoadMessagesBeforeTimestampAsync(ConversationId, _topLoadTimestamp, LoadCount);

            if (messages.VisibleMessages.Count == 0) {
                _endTop = true;
            } else {
                _endTop = false;
                _topLoadTimestamp = messages.VisibleMessages[0].CreatedAt;

                await _messageSemaphore!.WaitAsync();

                try {
                    _visibleMessages.InsertRange(0, messages.VisibleMessages);

                    foreach (var replyMessage in messages.RepliedMessages) {
                        _replyMessages.TryAdd(replyMessage.MessageId, replyMessage);
                    }
                } finally {
                    _messageSemaphore.Release();
                }
            }
        } finally {
            Interlocked.Exchange(ref _loadingTop, false);
            await InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task HandleLoadBottomMessages() {
        if (_endBottom) return;
        if (Interlocked.Exchange(ref _loadingBottom, true)) return;

        await InvokeAsync(StateHasChanged); // Re-render to display the load spinner.

        try {
            _savedScrollPositionForBottom = await _module!.InvokeAsync<ScrollInfo>("saveScrollPosition", _scrollContainer);

            var messages =
                await ConversationService.LoadMessagesAfterTimestampAsync(ConversationId, _topLoadTimestamp, LoadCount);

            if (messages.VisibleMessages.Count == 0) {
                _endBottom = true;
            } else {
                _endBottom = false;
                _bottomLoadTimestamp = messages.VisibleMessages[^1].CreatedAt;

                await _messageSemaphore!.WaitAsync();

                try {
                    _visibleMessages.AddRange(messages.VisibleMessages);

                    foreach (var replyMessage in messages.RepliedMessages) {
                        _replyMessages.TryAdd(replyMessage.MessageId, replyMessage);
                    }
                } finally {
                    _messageSemaphore.Release();
                }
            }
        } finally {
            Interlocked.Exchange(ref _loadingBottom, false);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleMessageReply(Guid id) {
        await OnReplyRequested.InvokeAsync(id);
    }

    private async Task HandleMessageReplyViaExtra() {
        if (!_showExtraActionPopover || _extraActionTargetMessage == null) {
            return;
        }
        
        await OnReplyRequested.InvokeAsync(_extraActionTargetMessage.MessageId);
        _showExtraActionPopover = false;
    }
    
    private void HandleMessageEdit(Guid id) {
        _editingMessageId = id;

        foreach (var message in _visibleMessages) {
            if (message.MessageId == id) {
                _editMessageBody = message.Body;
                break;
            }
        }

        _focusOnEditTextArea = true;
    }

    private void HandleMessageEditViaExtra() {
        if (!_showExtraActionPopover || _extraActionTargetMessage == null) {
            return;
        }
        
        HandleMessageEdit(_extraActionTargetMessage.MessageId);

        _showExtraActionPopover = false;
    }
    
    private async Task HandleSubmitMessageEdit() {
        _editMessageBody = _editMessageBody?.Trim();

        await ConversationService.EditMessageAsync(_editingMessageId, UserId, _editMessageBody);

        _editingMessageId = Guid.Empty;
        _editMessageBody = string.Empty;
    }

    private void HandleEscapeRequest() {
        _editingMessageId = Guid.Empty;
        _editMessageBody = string.Empty;
    }

    private async Task OpenUserProfileModal(string userId) {
        Guid? memberId = null;
        
        await using var dbContext = await DbContextFactory.CreateDbContextAsync();
        dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
        
        var channelId = await dbContext.Conversations
            .Where(c => c.Id == ConversationId)
            .Select(c => c.CommunityChannelId)
            .FirstOrDefaultAsync();

        if (channelId != null) {
            memberId = await dbContext.CommunityChannels
                .Where(r => r.Id == channelId)
                .Include(c => c.ChannelCategory)
                .ThenInclude(c => c.Community)
                .Select(c => c.ChannelCategory.Community.Members.FirstOrDefault(x => x.UserId == userId))
                .Select(m => m!.Id)
                .Cast<Guid?>()
                .FirstOrDefaultAsync();
        }

        ModalService.Open<UserProfileModal>(parameters: new Dictionary<string, object?> {
            [nameof(UserProfileModal.UserId)] = userId,
            [nameof(UserProfileModal.MemberId)] = memberId,
        });
    }

    private static readonly RenderFragment _deleteConfirmationBody = @<p>Are you sure you want to delete this message?<br/>This action cannot be reverted.</p>;
    
    private void HandleMessageDelete(Guid id) {
        ModalService.Open<OperationConfirmModal>(parameters: new Dictionary<string, object?> {
            [nameof(OperationConfirmModal.Title)] = "Delete Message",
            [nameof(OperationConfirmModal.Body)] = _deleteConfirmationBody,
            [nameof(OperationConfirmModal.OnConfirm)] = EventCallback.Factory.Create(this, async () => {
                await ConversationService.DeleteMessageAsync(id, UserId);
            }),
        });
    }
    
    private void HandleMessageDeleteViaExtra() {
        if (!_showExtraActionPopover || _extraActionTargetMessage == null) {
            return;
        }
        
        ModalService.Open<OperationConfirmModal>(parameters: new Dictionary<string, object?> {
            [nameof(OperationConfirmModal.Title)] = "Delete Message",
            [nameof(OperationConfirmModal.Body)] = _deleteConfirmationBody,
            [nameof(OperationConfirmModal.OnConfirm)] = EventCallback.Factory.Create(this, async () => {
                await ConversationService.DeleteMessageAsync(_extraActionTargetMessage.MessageId, UserId);
            }),
        });

        _showExtraActionPopover = false;
    }

    private void HandleShowExtraActionPopover(IConversationService.RenderingMessageDTO messageDTO) {
        if (_extraActionPopoverTargets.TryGetValue(messageDTO.MessageId, out var target)) {
            _extraActionTargetMessage = messageDTO;
            _showExtraActionPopover = true;
            _extraActionTargetElement = target;
        } else {
            _extraActionTargetMessage = null;
            _showExtraActionPopover = false;
            _extraActionTargetElement = default;
        }
    }

    private void SetIsShowingExtraActionPopover(bool value) {
        _showExtraActionPopover = value;
    }

    private async Task HandleCopyMessage() {
        if (!_showExtraActionPopover || _extraActionTargetMessage == null) {
            return;
        }

        await JavascriptRuntime.InvokeVoidAsync("window.copyToClipboard", _extraActionTargetMessage.Body);
        _showExtraActionPopover = false;
    }

    private void HandleReportMessage() {
        if (!_showExtraActionPopover || _extraActionTargetMessage == null) {
            return;
        }

        ModalService.Open<ReportMessageModal>(parameters: new Dictionary<string, object?> {
            [nameof(ReportMessageModal.MessageId)] = _extraActionTargetMessage.MessageId,
            [nameof(ReportMessageModal.ReporterId)] = MemberInformation!.Value.MemberId,
        });

        _showExtraActionPopover = false;
    }

    private void OnMessageReceived(MessageReceivedEventArgs args) {
        // Only insert if we're at the bottom.
        if (_endBottom && args.ConversationId == ConversationId) {
            InvokeAsync((Func<Task>)(async () => {
                _jumpToBottom = await _module!.InvokeAsync<bool>("shouldMaintainScrollBottom", _scrollContainer);

                await using var dbContext = await DbContextFactory.CreateDbContextAsync();
                dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
                
                var senderData = await dbContext.Users
                    .Where(u => u.Id == args.SenderId)
                    .Select(u => new {
                        u.Id,
                        u.DisplayName,
                        u.AvatarProfilePath,
                    })
                    .FirstAsync();

                IConversationService.RenderingReplyMessageDTO? replyMessage = null;

                var messageData = await dbContext.ChatMessages
                    .Where(m => m.Id == args.MessageId)
                    .Select(m => new {
                        m.ReplyMessageId,
                        m.Body,
                        m.CreatedAt,
                        m.Attachments,
                    })
                    .FirstAsync();

                if (messageData.ReplyMessageId.HasValue && !_replyMessages.ContainsKey(messageData.ReplyMessageId.Value)) {
                    replyMessage = await dbContext.ChatMessages
                        .Where(m => m.Id == messageData.ReplyMessageId.Value && m.DeletedAt == null)
                        .Include(m => m.Sender)
                        .Select(m => new IConversationService.RenderingReplyMessageDTO(m.Id, m.Sender.DisplayName, m.Body))
                        .FirstOrDefaultAsync();
                }

                await _messageSemaphore!.WaitAsync();

                try {
                    _visibleMessages.Add(new(args.MessageId, senderData.Id, senderData.DisplayName, senderData.AvatarProfilePath, messageData.Body, messageData.CreatedAt, false, messageData.ReplyMessageId, messageData.Attachments));

                    if (replyMessage != null) {
                        _replyMessages.TryAdd(replyMessage.MessageId, replyMessage);
                    }
                } finally {
                    _messageSemaphore.Release();
                }

                StateHasChanged();
            }));
        }
    }

    private void OnMessageDeleted(MessageDeletedEventArgs args) {
        if (ConversationId != args.ConversationId) return;

        _messageSemaphore!.Wait();

        try {
            for (int i = 0; i < _visibleMessages.Count; i++) {
                if (_visibleMessages[i].MessageId == args.MessageId) {
                    _visibleMessages.RemoveAt(i);
                    break;
                }
            }

            InvokeAsync(StateHasChanged);
        } finally {
            _messageSemaphore.Release();
        }
    }

    private void OnMessageEdited(MessageEditedEventArgs args) {
        if (ConversationId != args.ConversationId) return;

        _messageSemaphore!.Wait();

        try {
            for (int i = 0; i < _visibleMessages.Count; i++) {
                if (_visibleMessages[i].MessageId == args.MessageId) {
                    _visibleMessages[i] = _visibleMessages[i] with {
                        Body = args.Body,
                        IsEdited = true,
                    };
                    break;
                }
            }

            InvokeAsync(StateHasChanged);
        } finally {
            _messageSemaphore.Release();
        }
    }
    
    public async ValueTask DisposeAsync() {
        ConversationEventDispatcher.OnMessageReceived -= OnMessageReceived;
        ConversationEventDispatcher.OnMessageDeleted -= OnMessageDeleted;
        ConversationEventDispatcher.OnMessageEdited -= OnMessageEdited;

        _messageSemaphore?.Dispose();
        
        await ConversationEventDispatcher.Disconnect(ConversationId);
    }
    
    private enum InitializationStatus {
        Loading,
        Success,
    }
    
    private record ScrollInfo(double ScrollTop, double ScrollHeight);
}