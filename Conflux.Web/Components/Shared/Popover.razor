@using System.Globalization

@implements IAsyncDisposable

@inject IJSRuntime JavascriptRuntime
@inject ILogger<Popover> Logger

@if (IsShowing) {
    <div class="absolute inset-0 pointer-events-none z-10" tabindex="-1">
        <div class="absolute pointer-events-auto @_cssClass" @attributes="AdditionalAttributes" @ref="_popover" style="left: -9999px; top: -9999px;">
            @ChildContent

            @if (DisplayArrow) {
                <div class="absolute size-2 rotate-45 @ArrowCssClass" @ref="_arrow"></div>
            }
        </div>
    </div>
}

@code {
    [Parameter] public ElementReference TargetReference { get; set; }
    [Parameter, EditorRequired] public required RenderFragment ChildContent { get; set; }
    [Parameter] public string? ArrowCssClass { get; set; }
    
    [Parameter] public bool IsShowing { get; set; }
    [Parameter] public EventCallback<bool> IsShowingChanged { get; set; }

    [Parameter] public string Placement { get; set; } = "right";
    [Parameter] public float Offset { get; set; }
    [Parameter] public bool CloseWhenClickOutside { get; set; }

    [Parameter] public bool DisplayArrow { get; set; } = true;

    [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    private string? _cssClass;
    
    private ElementReference _popover;
    private ElementReference? _arrow;

    private bool _isShowing;
    
    private IJSObjectReference? _module;
    private DotNetObjectReference<Popover>? _selfReference;

    private IJSObjectReference? _disposer;
    
    protected override void OnParametersSet() {
        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("class", out object? obj)) {
            _cssClass = Convert.ToString(obj, CultureInfo.InvariantCulture);
        }

        AdditionalAttributes = AdditionalAttributes?.Where(x => x.Key != "class").ToDictionary();
        _isShowing = IsShowing;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            _module = await JavascriptRuntime.InvokeAsync<IJSObjectReference>("import", "./js/Components/Popover.js");
            _selfReference = DotNetObjectReference.Create(this);
        }

        if (_module != null) {
            if (_isShowing) {
                if (_disposer == null) {
                    _disposer = await _module.InvokeAsync<IJSObjectReference>("register", TargetReference, _popover, _arrow, Placement, Offset, _selfReference, CloseWhenClickOutside);
                }
            } else {
                if (_disposer != null) {
                    await _module!.InvokeVoidAsync("unregister", _disposer);
                    await _disposer.DisposeAsync();
                
                    _disposer = null;
                }
            }
        }
    }
    
    [JSInvokable]
    public async Task HandleOutsideClick() {
        if (!CloseWhenClickOutside || !_isShowing || _disposer == null) return;
        
        var currentDisposer = _disposer;
        _disposer = null;

        try {
            if (_module != null) {
                await _module.InvokeVoidAsync("unregister", currentDisposer);
                await currentDisposer.DisposeAsync();
            }
        } catch (Exception e) {
            Logger.LogError("Failed to close popover when click outside: {msg}.", e.Message);
        }

        _isShowing = false;
        await IsShowingChanged.InvokeAsync(_isShowing);
    }
    
    public async ValueTask DisposeAsync() {
        _selfReference?.Dispose();
        
        if (_module != null) {
            try {
                if (_disposer != null) {
                    await _module.InvokeVoidAsync("unregister", _disposer);
                    await _disposer.DisposeAsync();
                    
                    _disposer = null;
                }
                
                await _module.DisposeAsync();

            } catch (JSDisconnectedException) {
            }
        }
    }
}