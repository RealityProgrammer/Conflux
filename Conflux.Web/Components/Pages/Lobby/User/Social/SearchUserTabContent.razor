@using Conflux.Application.Dto
@using Conflux.Domain.Events
@using Conflux.Web.Components.Shared.Modals
@using Conflux.Web.Helpers
@using Conflux.Web.Services.Implementations
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore
@using System.Collections.Concurrent

@implements IAsyncDisposable

@inject ILogger<SearchUserTabContent> Logger
@inject UserManager<ApplicationUser> UserManager
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IFriendshipService FriendshipService
@inject IFriendshipEventDispatcher FriendshipEventDispatcher
@inject IContentService ContentService
@inject ModalService ModalService

<SearchField @bind-Value="_nameSearch" @bind-Value:after="StartSearchDebouncing" class="flex-none h-10"/>

<div class="flex-1 overflow-auto mt-2 border border-gray-600 rounded-lg p-1">
    <Virtualize @ref="_virtualizeContainer" ItemsProvider="LoadProvider">
        <ChildContent Context="item">
            @{ var userId = item.UserDisplay.UserId; }
            
            <UserCard @key="userId"
                      UserId="userId"
                      UserName="@item.UserDisplay.UserName"
                      DisplayName="@item.UserDisplay.DisplayName"
                      AvatarSrc="@(string.IsNullOrEmpty(item.UserDisplay.AvatarPath) ? null : ContentService.GetAssetPath(item.UserDisplay.AvatarPath))"
                      OnClick="card => HandleOnUserCardClick(card)"
                      class="h-12 group">
                <RightContent>
                    <div class="flex-none flex-row gap-4 hidden group-hover:flex mr-3" @onclick:stopPropagation="true">
                        @{ FriendRequestProcessingAction action; }

                        @switch (item.FriendStatus) {
                            case FriendStatus.Stranger:
                                <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(userId, out action) && action == FriendRequestProcessingAction.Sending)" NormalCssClass="group/button cursor-pointer" @onclick="@(() => HandleSendFriendRequest(item))">
                                    <ChildContent>
                                        <Person Addition="PersonAddition.Add" class="size-6 fill-gray-300 group-hover/button:fill-white"/>
                                    </ChildContent>
                
                                    <ProcessingContent>
                                        <Spinner class="size-6 fill-white"/>
                                    </ProcessingContent>
                                </ProcessingStateButton>
                                break;

                            case FriendStatus.OutcomingPending:
                                <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(userId, out action) && action == FriendRequestProcessingAction.Cancelling)" NormalCssClass="group/button cursor-pointer" @onclick="@(() => HandleCancelFriendRequest(item))">
                                    <ChildContent>
                                        <Cross class="size-6 fill-gray-300 group-hover/button:fill-white"/>
                                    </ChildContent>

                                    <ProcessingContent>
                                        <Spinner class="size-6 fill-white"/>
                                    </ProcessingContent>
                                </ProcessingStateButton>
                                break;

                            case FriendStatus.IncomingPending:
                                <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(userId, out action) && action == FriendRequestProcessingAction.Accepting)" NormalCssClass="group/button cursor-pointer" @onclick="@(() => HandleAcceptFriendRequest(item))">
                                    <ChildContent>
                                        <Person Addition="PersonAddition.Check" class="size-6 fill-green-600 group-hover/button:fill-green-400"/>
                                    </ChildContent>

                                    <ProcessingContent>
                                        <Spinner class="size-6 fill-white"/>
                                    </ProcessingContent>
                                </ProcessingStateButton>

                                <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(userId, out action) && action == FriendRequestProcessingAction.Rejecting)" NormalCssClass="group/button cursor-pointer" @onclick="@(() => HandleRejectFriendRequest(item))">
                                    <ChildContent>
                                        <Cross class="size-6 fill-red-600 group-hover/button:fill-red-400"/>
                                    </ChildContent>

                                    <ProcessingContent>
                                        <Spinner class="size-6 fill-white"/>
                                    </ProcessingContent>
                                </ProcessingStateButton>
                                break;

                            case FriendStatus.Friend:
                                <div class="p-2 rounded-full">
                                    <Person Addition="PersonAddition.Check" class="size-6 fill-green-400"/>
                                </div>
                                break;
                        }
                    </div>
                </RightContent>
            </UserCard>
        </ChildContent>
        
        <EmptyContent>
            <div class="flex flex-row justify-center items-center h-full">
                <p class="text-gray-400">@(string.IsNullOrEmpty(_nameSearch) ? "Type something in the searchbar" : "Empty...")</p>
            </div>
        </EmptyContent>
    </Virtualize>
</div>

@code {
    private string _nameSearch = string.Empty;

    // TODO: First search always have to wait before result display, can we skip that and only wait on
    // later searches?
    private Debouncer? _searchDebouncer;

    private Virtualize<SearchDTO> _virtualizeContainer = null!;

    [CascadingParameter(Name = "SessionUserId")] private Guid UserId { get; set; }

    private ConcurrentDictionary<Guid, FriendRequestProcessingAction> _processingFriendRequests = [];

    protected override void OnAfterRender(bool firstRender) {
        if (firstRender) {
            _searchDebouncer = new(OnDebounceEnd, TimeSpan.FromMilliseconds(250));

            FriendshipEventDispatcher.OnFriendRequestReceived += OnFriendRequestReceivedNotification;
            FriendshipEventDispatcher.OnFriendRequestCanceled += OnFriendRequestCanceledNotification;
            FriendshipEventDispatcher.OnFriendRequestRejected += OnFriendRequestRejectedNotification;
            FriendshipEventDispatcher.OnFriendRequestAccepted += OnFriendRequestAcceptedNotification;
        }
    }

    private async Task StartSearchDebouncing() {
        if (_searchDebouncer == null) {
            return;
        }
        
        await _searchDebouncer.Start();
    }

    private async Task OnDebounceEnd(CancellationToken token) {
        await _virtualizeContainer.RefreshDataAsync();
        StateHasChanged();
    }

    private async ValueTask<ItemsProviderResult<SearchDTO>> LoadProvider(ItemsProviderRequest request) {
        try {
            if (string.IsNullOrEmpty(_nameSearch)) {
                return new([], 0);
            }

            string namePattern = $"%{_nameSearch}%";
            
            // TODO: Filter blocked users.
            await using var dbContext = await DbContextFactory.CreateDbContextAsync();
            var query = dbContext.Users
                .Where(u => u.IsProfileSetup && u.EmailConfirmed && u.Id != UserId && (EF.Functions.ILike(u.UserName!, namePattern) || EF.Functions.ILike(u.DisplayName, namePattern)))
                .OrderBy(u => u.CreatedAt);
            
            int totalCount = await query.CountAsync();

            if (totalCount == 0) {
                return new([], 0);
            }

            List<SearchDTO> results = await query
                .Skip(request.StartIndex)
                .Take(request.Count)
                .Select(user => new {
                    User = user,
                    FriendRequest = user.SentFriendRequests
                        .Where(fr => fr.ReceiverUserId == UserId)
                        .Concat(
                            user.ReceivedFriendRequests
                                .Where(fr => fr.SenderUserId == UserId)
                            )
                        .FirstOrDefault(),
                })
                .Select(x => new SearchDTO(
                    new(x.User.Id, x.User.DisplayName, x.User.UserName, x.User.AvatarProfilePath),
                    x.FriendRequest == null ? FriendStatus.Stranger
                    : x.FriendRequest.Status == FriendRequestStatus.Accepted ? FriendStatus.Friend
                    : x.FriendRequest.Status == FriendRequestStatus.Pending ? x.FriendRequest.SenderUserId == UserId ? FriendStatus.OutcomingPending : FriendStatus.IncomingPending
                    : FriendStatus.Stranger,
                    x.FriendRequest == null ? null : x.FriendRequest.Id
                ))
                .ToListAsync();

            return new(results, totalCount);
        } catch (Exception e) {
            Logger.LogError(e, "Error: ");
            throw;
        }
    }
    
    private void HandleOnUserCardClick(UserCard card) {
        ModalService.Open<UserProfileModal>(parameters: new Dictionary<string, object?> {
            [nameof(UserProfileModal.InspectingUserId)] = card.UserId,
        });
    }

    private async Task HandleSendFriendRequest(SearchDTO item) {
        var userId = item.UserDisplay.UserId;
        
        if (_processingFriendRequests.TryAdd(userId, FriendRequestProcessingAction.Sending)) {
            try {
                var sendStatus = (await FriendshipService.SendFriendRequestAsync(UserId, userId)).Status;

                switch (sendStatus) {
                    case IFriendshipService.SendingStatus.Success:
                        item.FriendStatus = FriendStatus.OutcomingPending;
                        break;
                        
                    case IFriendshipService.SendingStatus.IncomingPending:
                        item.FriendStatus = FriendStatus.IncomingPending;
                        break;
                        
                    case IFriendshipService.SendingStatus.OutcomingPending:
                        // Already send a friend request, how the hell did we get here?
                        break;
                        
                    case IFriendshipService.SendingStatus.Failed:
                        Logger.LogWarning("Failed to send friend request from user {f} to {r}.", UserId, userId);
                        break;
                        
                    case IFriendshipService.SendingStatus.Friended:
                        item.FriendStatus = FriendStatus.Friend;
                        break;
                }
            } finally {
                _processingFriendRequests.TryRemove(userId, out _);

                if (_processingFriendRequests.IsEmpty) {
                    await _virtualizeContainer.RefreshDataAsync();
                    StateHasChanged();
                }
            }
        }
    }

    private async Task HandleCancelFriendRequest(SearchDTO item) {
        if (item.FriendRequestId is not { } friendRequestId) {
            return;
        }
        
        var userId = item.UserDisplay.UserId;
        
        if (_processingFriendRequests.TryAdd(userId, FriendRequestProcessingAction.Cancelling)) {
            try {
                if (!await FriendshipService.CancelFriendRequestAsync(friendRequestId)) {
                    Logger.LogWarning("Failed to cancel friend request from user {f} to {r}.", UserId, userId);
                }
                
                item.FriendStatus = FriendStatus.Stranger;
            } finally {
                _processingFriendRequests.TryRemove(userId, out _);

                if (_processingFriendRequests.IsEmpty) {
                    await _virtualizeContainer.RefreshDataAsync();
                    StateHasChanged();
                }
            }
        }
    }
    
    private async Task HandleRejectFriendRequest(SearchDTO item) {
        if (item.FriendRequestId is not { } friendRequestId) {
            return;
        }
        
        var userId = item.UserDisplay.UserId;
        
        if (_processingFriendRequests.TryAdd(userId, FriendRequestProcessingAction.Rejecting)) {
            try {
                if (!await FriendshipService.RejectFriendRequestAsync(friendRequestId)) {
                    Logger.LogWarning("Failed to reject friend request from user {f} to {r}.", userId, UserId);
                }
                
                item.FriendStatus = FriendStatus.Stranger;
            } finally {
                _processingFriendRequests.TryRemove(userId, out _);

                if (_processingFriendRequests.IsEmpty) {
                    await _virtualizeContainer.RefreshDataAsync();
                    StateHasChanged();
                }
            }
        }
    }
    
    private async Task HandleAcceptFriendRequest(SearchDTO item) {
        if (item.FriendRequestId is not { } friendRequestId) {
            return;
        }

        var userId = item.UserDisplay.UserId;
        
        if (_processingFriendRequests.TryAdd(userId, FriendRequestProcessingAction.Accepting)) {
            try {
                if (!await FriendshipService.AcceptFriendRequestAsync(friendRequestId)) {
                    Logger.LogWarning("Failed to accept friend request from user {f} to {r}.", userId, UserId);
                }
                
                item.FriendStatus = FriendStatus.Friend;
            } finally {
                _processingFriendRequests.TryRemove(userId, out _);

                if (_processingFriendRequests.IsEmpty) {
                    await _virtualizeContainer.RefreshDataAsync();
                    StateHasChanged();
                }
            }
        }
    }
    
    private void OnFriendRequestReceivedNotification(FriendRequestReceivedEventArgs eventArgs) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }
    
    private void OnFriendRequestRejectedNotification(FriendRequestRejectedEventArgs eventArgs) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }

    private void OnFriendRequestCanceledNotification(FriendRequestCanceledEventArgs eventArgs) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }
    
    private void OnFriendRequestAcceptedNotification(FriendRequestAcceptedEventArgs eventArgs) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }

    public async ValueTask DisposeAsync() {
        if (_searchDebouncer != null) {
            await _searchDebouncer.DisposeAsync();
        }
        
        FriendshipEventDispatcher.OnFriendRequestReceived -= OnFriendRequestReceivedNotification;
        FriendshipEventDispatcher.OnFriendRequestCanceled -= OnFriendRequestCanceledNotification;
        FriendshipEventDispatcher.OnFriendRequestRejected -= OnFriendRequestRejectedNotification;
        FriendshipEventDispatcher.OnFriendRequestAccepted -= OnFriendRequestAcceptedNotification;
    }

    private enum FriendRequestProcessingAction {
        Sending,
        Cancelling,
        Rejecting,
        Accepting,
    }
    
    public enum FriendStatus {
        Stranger,
        OutcomingPending,
        IncomingPending,
        Friend,
    }

    private record struct SearchDTO(UserDisplayDTO UserDisplay, FriendStatus FriendStatus, Guid? FriendRequestId);
}