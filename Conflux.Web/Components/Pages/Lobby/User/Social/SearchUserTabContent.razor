@using Conflux.Components.Shared
@using Conflux.Components.Shared.Icons
@using Conflux.Domain.Events
@using Conflux.Helpers
@using Conflux.Services.Abstracts
@using Microsoft.AspNetCore.Identity
@using Microsoft.EntityFrameworkCore
@using System.Collections.Concurrent
@using System.Diagnostics
@using System.Security.Claims

@implements IDisposable

@inject ILogger<SearchUserTabContent> Logger
@inject UserManager<ApplicationUser> UserManager
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IFriendshipService FriendshipService
@inject IFriendshipEventDispatcher FriendshipEventDispatcher
@inject IContentService ContentService

<div class="flex-none px-3 outline-none border rounded-lg bg-gray-700/60 border-gray-600 focus-within:ring-2 focus-within:ring-indigo-600 transition duration-300 flex flex-row items-center">
    <Search class="size-4 fill-white flex-none mr-2"/>

    <input type="text" class="flex-1 outline-none border-none w-full h-11 focus:outline-none" @bind="_nameSearch" @bind:after="HandleSearchDebouncing" maxlength="32">
</div>

<div class="flex-1 overflow-auto mt-2 border border-gray-600 rounded-lg">
    <Virtualize @ref="_virtualizeContainer" ItemsProvider="LoadProvider" OverscanCount="3">
        <ChildContent Context="item">
            <div @key="item.UserId" class="h-16 px-4 py-1 border-b border-b-gray-600 flex flex-row items-center hover:bg-gray-600/40 group">
                <Avatar ImageSrc="@(string.IsNullOrEmpty(item.AvatarPath) ? null : ContentService.GetAssetPath(item.AvatarPath))" 
                        ImageAlt="@($"Avatar of {item.DisplayName}")" 
                        class="flex-none h-12 mr-2"/>
            
                <div class="flex-1 flex flex-col">
                    <p class="font-semibold">@item.DisplayName</p>
                    <p class="text-sm">@item.UserName</p>
                </div>
            
                <div class="flex-none flex-row gap-1 hidden group-hover:flex">
                    @{
                        FriendRequestProcessingAction action;
                    }
                    
                    @switch (item.FriendStatus) {
                        case FriendStatus.Stranger:
                            <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(item.UserId, out action) && action == FriendRequestProcessingAction.Sending)" class="p-2 rounded-full" NormalCssClass="hover:bg-gray-400/50 cursor-pointer" @onclick="@(() => HandleSendFriendRequest(item))">
                                <ChildContent>
                                    <Person Addition="PersonAddition.Add" class="size-6 fill-white"/>
                                </ChildContent>

                                <ProcessingContent>
                                    <Spinner class="size-6 fill-white"/>
                                </ProcessingContent>
                            </ProcessingStateButton>
                            break;
                            
                        case FriendStatus.OutcomingPending:
                            <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(item.UserId, out action) && action == FriendRequestProcessingAction.Cancelling)" class="p-2 rounded-full" NormalCssClass="hover:bg-gray-400/50 cursor-pointer" @onclick="@(() => HandleCancelFriendRequest(item))">
                                <ChildContent>
                                    <Cross class="size-6 fill-white"/>
                                </ChildContent>

                                <ProcessingContent>
                                    <Spinner class="size-6 fill-white"/>
                                </ProcessingContent>
                            </ProcessingStateButton>
                            break;
                            
                        case FriendStatus.IncomingPending:
                            <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(item.UserId, out action) && action == FriendRequestProcessingAction.Accepting)" class="p-2 rounded-full" NormalCssClass="hover:bg-gray-400/50 cursor-pointer" @onclick="@(() => HandleAcceptFriendRequest(item))">
                                <ChildContent>
                                    <Person Addition="PersonAddition.Check" class="size-6 fill-green-400"/>
                                </ChildContent>

                                <ProcessingContent>
                                    <Spinner class="size-6 fill-white"/>
                                </ProcessingContent>
                            </ProcessingStateButton>
                            
                            <ProcessingStateButton IsProcessing="@(_processingFriendRequests.TryGetValue(item.UserId, out action) && action == FriendRequestProcessingAction.Rejecting)" class="p-2 rounded-full" NormalCssClass="hover:bg-gray-400/50 cursor-pointer" @onclick="@(() => HandleRejectFriendRequest(item))">
                                <ChildContent>
                                    <Cross class="size-6 fill-red-500"/>
                                </ChildContent>

                                <ProcessingContent>
                                    <Spinner class="size-6 fill-white"/>
                                </ProcessingContent>
                            </ProcessingStateButton>
                            break;
                            
                        case FriendStatus.Friend:
                            <div class="p-2 rounded-full">
                                <Person Addition="PersonAddition.Check" class="size-6 fill-green-400"/>
                            </div>
                            break;
                    }

                    <button class="p-2 rounded-full hover:bg-gray-400/50 cursor-pointer">
                        <ThreeDots class="size-6 fill-white"/>
                    </button>
                </div>
            </div>
        </ChildContent>
        
        <EmptyContent>
            <div class="flex flex-row justify-center items-center h-full">
                <p class="text-gray-400">Empty...</p>
            </div>
        </EmptyContent>
    </Virtualize>
</div>

@code {
    private string _nameSearch = string.Empty;
    private string _normalizedNameSearch = string.Empty;

    // TODO: First search always have to wait before result display, can we skip that and only wait on
    // later searches?
    private Debouncer _searchDebouncer = null!;

    private Virtualize<SearchDTO> _virtualizeContainer = null!;

    [CascadingParameter] private Task<AuthenticationState> AuthenticationState { get; set; } = null!;
    private string _userId = null!;

    private ConcurrentDictionary<string, FriendRequestProcessingAction> _processingFriendRequests = [];

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            _searchDebouncer = new(OnDebounceEnd, TimeSpan.FromMilliseconds(250));

            var authState = await AuthenticationState;
            _userId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier)!;
            
            Debug.Assert(_userId != null);

            FriendshipEventDispatcher.OnFriendRequestReceived += OnFriendRequestReceivedNotification;
            FriendshipEventDispatcher.OnFriendRequestCanceled += OnFriendRequestCanceledNotification;
            FriendshipEventDispatcher.OnFriendRequestRejected += OnFriendRequestRejectedNotification;
            FriendshipEventDispatcher.OnFriendRequestAccepted += OnFriendRequestAcceptedNotification;
        }
    }

    private async Task HandleSearchDebouncing() {
        await _searchDebouncer.Start();
    }

    private async Task OnDebounceEnd(CancellationToken token) {
        _normalizedNameSearch = UserManager.NormalizeName(_nameSearch.Trim());

        await _virtualizeContainer.RefreshDataAsync();
        StateHasChanged();
    }

    private async ValueTask<ItemsProviderResult<SearchDTO>> LoadProvider(ItemsProviderRequest request) {
        try {
            if (string.IsNullOrEmpty(_normalizedNameSearch)) {
                return new([], 0);
            }
            
            // TODO: Filter blocked users.
            await using var dbContext = await DbContextFactory.CreateDbContextAsync();
            var query = dbContext.Users
                .Where(u => u.IsProfileSetup && u.EmailConfirmed && u.Id != _userId && (u.NormalizedUserName!.Contains(_normalizedNameSearch) || EF.Functions.ILike(u.DisplayName, $"%{_normalizedNameSearch}%")))
                .OrderBy(u => u.CreatedAt);

            int totalCount = await query.CountAsync();

            if (totalCount == 0) {
                return new([], 0);
            }

            List<SearchDTO> results = await query
                .Skip(request.StartIndex)
                .Take(request.Count)
                .Select(user => new {
                    User = user,
                    FriendRequest = user.SentFriendRequests
                        .Where(fr => fr.ReceiverId == _userId)
                        .Concat(
                            user.ReceivedFriendRequests
                                .Where(fr => fr.SenderId == _userId)
                            )
                        .FirstOrDefault(),
                })
                .Select(x => new SearchDTO(
                    x.User.Id,
                    x.User.DisplayName,
                    x.User.UserName!,
                    x.User.AvatarProfilePath,
                    x.FriendRequest == null ? FriendStatus.Stranger
                    : x.FriendRequest.Status == FriendRequestStatus.Accepted ? FriendStatus.Friend
                    : x.FriendRequest.Status == FriendRequestStatus.Pending ? x.FriendRequest.SenderId == _userId ? FriendStatus.OutcomingPending : FriendStatus.IncomingPending
                    : FriendStatus.Stranger,
                    x.FriendRequest == null ? null : x.FriendRequest.Id
                ))
                .ToListAsync();

            return new(results, totalCount);
        } catch (Exception e) {
            Logger.LogError(e, "Error: ");
            throw;
        }
    }

    private async Task HandleSendFriendRequest(SearchDTO item) {
        if (_processingFriendRequests.TryAdd(item.UserId, FriendRequestProcessingAction.Sending)) {
            try {
                string receiverId = item.UserId;

                var sendStatus = (await FriendshipService.SendFriendRequestAsync(_userId, receiverId)).Status;

                switch (sendStatus) {
                    case IFriendshipService.SendingStatus.Success:
                        item.FriendStatus = FriendStatus.OutcomingPending;
                        break;
                        
                    case IFriendshipService.SendingStatus.IncomingPending:
                        item.FriendStatus = FriendStatus.IncomingPending;
                        break;
                        
                    case IFriendshipService.SendingStatus.OutcomingPending:
                        // Already send a friend request, how the hell did we get here?
                        break;
                        
                    case IFriendshipService.SendingStatus.Failed:
                        Logger.LogWarning("Failed to send friend request from user {f} to {r}.", _userId, receiverId);
                        break;
                        
                    case IFriendshipService.SendingStatus.Friended:
                        item.FriendStatus = FriendStatus.Friend;
                        break;
                }
            } finally {
                _processingFriendRequests.TryRemove(item.UserId, out _);

                if (_processingFriendRequests.IsEmpty) {
                    await _virtualizeContainer.RefreshDataAsync();
                    StateHasChanged();
                }
            }
        }
    }

    private async Task HandleCancelFriendRequest(SearchDTO item) {
        if (item.FriendRequestId is not { } friendRequestId) {
            return;
        }
        
        if (_processingFriendRequests.TryAdd(item.UserId, FriendRequestProcessingAction.Cancelling)) {
            try {
                string receiverId = item.UserId;

                if (!await FriendshipService.CancelFriendRequestAsync(friendRequestId)) {
                    Logger.LogWarning("Failed to cancel friend request from user {f} to {r}.", _userId, receiverId);
                }
                
                item.FriendStatus = FriendStatus.Stranger;
            } finally {
                _processingFriendRequests.TryRemove(item.UserId, out _);

                if (_processingFriendRequests.IsEmpty) {
                    await _virtualizeContainer.RefreshDataAsync();
                    StateHasChanged();
                }
            }
        }
    }
    
    private async Task HandleRejectFriendRequest(SearchDTO item) {
        if (item.FriendRequestId is not { } friendRequestId) {
            return;
        }
        
        if (_processingFriendRequests.TryAdd(item.UserId, FriendRequestProcessingAction.Rejecting)) {
            try {
                if (!await FriendshipService.RejectFriendRequestAsync(friendRequestId)) {
                    Logger.LogWarning("Failed to reject friend request from user {f} to {r}.", item.UserId, _userId);
                }
                
                item.FriendStatus = FriendStatus.Stranger;
            } finally {
                _processingFriendRequests.TryRemove(item.UserId, out _);

                if (_processingFriendRequests.IsEmpty) {
                    await _virtualizeContainer.RefreshDataAsync();
                    StateHasChanged();
                }
            }
        }
    }
    
    private async Task HandleAcceptFriendRequest(SearchDTO item) {
        if (item.FriendRequestId is not { } friendRequestId) {
            return;
        }
        
        if (_processingFriendRequests.TryAdd(item.UserId, FriendRequestProcessingAction.Accepting)) {
            try {
                if (!await FriendshipService.AcceptFriendRequestAsync(friendRequestId)) {
                    Logger.LogWarning("Failed to accept friend request from user {f} to {r}.", item.UserId, _userId);
                }
                
                item.FriendStatus = FriendStatus.Friend;
            } finally {
                _processingFriendRequests.TryRemove(item.UserId, out _);

                if (_processingFriendRequests.IsEmpty) {
                    await _virtualizeContainer.RefreshDataAsync();
                    StateHasChanged();
                }
            }
        }
    }
    
    private void OnFriendRequestReceivedNotification(FriendRequestReceivedEventArgs eventArgs) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }
    
    private void OnFriendRequestRejectedNotification(FriendRequestRejectedEventArgs eventArgs) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }

    private void OnFriendRequestCanceledNotification(FriendRequestCanceledEventArgs eventArgs) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }
    
    private void OnFriendRequestAcceptedNotification(FriendRequestAcceptedEventArgs eventArgs) {
        InvokeAsync(async () => {
            await _virtualizeContainer.RefreshDataAsync();
            StateHasChanged();
        });
    }

    public void Dispose() {
        _searchDebouncer.Dispose();
        
        FriendshipEventDispatcher.OnFriendRequestReceived -= OnFriendRequestReceivedNotification;
        FriendshipEventDispatcher.OnFriendRequestCanceled -= OnFriendRequestCanceledNotification;
        FriendshipEventDispatcher.OnFriendRequestRejected -= OnFriendRequestRejectedNotification;
        FriendshipEventDispatcher.OnFriendRequestAccepted -= OnFriendRequestAcceptedNotification;
    }

    private enum FriendRequestProcessingAction {
        Sending,
        Cancelling,
        Rejecting,
        Accepting,
    }
    
    public enum FriendStatus {
        Stranger,
        OutcomingPending,
        IncomingPending,
        Friend,
    }

    private record struct SearchDTO(string UserId, string DisplayName, string UserName, string? AvatarPath, FriendStatus FriendStatus, Guid? FriendRequestId);
}